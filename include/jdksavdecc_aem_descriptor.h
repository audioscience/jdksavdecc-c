#pragma once

/*
  Copyright (c) 2013, J.D. Koftinoff Software, Ltd.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of J.D. Koftinoff Software, Ltd. nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
*/

#include "jdksavdecc_world.h"
#include "jdksavdecc_aecp_aem.h"

#ifdef __cplusplus
extern "C" {
#endif

/** \addtogroup aem AEM - Clause 7 */
/*@{*/

/** \addtogroup aem_descriptor AEM Descriptors - Clause 7.2 */
/*@{*/

#define JDKSAVDECC_AEM_VALUES_TYPE_FLAG_READ_ONLY (0x8000)
#define JDKSAVDECC_AEM_VALUES_TYPE_FLAG_UNKNOWN (0x4000)

/// Clause 7.3.3
#define JDKSAVDECC_AEM_UNITS(multiplier, code) ((multiplier << 8) + code)

/** \addtogroup descriptor */
/*@{*/

#define JDKSAVDECC_AEM_DESCRIPTOR_SIZE (508) /// Clause 7.2

struct jdksavdecc_descriptor {
    uint8_t data[JDKSAVDECC_AEM_DESCRIPTOR_SIZE];
};

/*@}*/

/** \addtogroup descriptor descriptor : Descriptor Types - Clause 7.2  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_ENTITY (0x0000)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION (0x0001)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_UNIT (0x0002)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_UNIT (0x0003)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_UNIT (0x0004)
#define JDKSAVDECC_DESCRIPTOR_STREAM_INPUT (0x0005)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OUTPUT (0x0006)
#define JDKSAVDECC_DESCRIPTOR_JACK_INPUT (0x0007)
#define JDKSAVDECC_DESCRIPTOR_JACK_OUTPUT (0x0008)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE (0x0009)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE (0x000a)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT (0x000b)
#define JDKSAVDECC_DESCRIPTOR_LOCALE (0x000c)
#define JDKSAVDECC_DESCRIPTOR_STRINGS (0x000d)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_INPUT (0x000e)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OUTPUT (0x000f)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_INPUT (0x0010)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OUTPUT (0x0011)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_INPUT (0x0012)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OUTPUT (0x0013)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER (0x0014)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER (0x0015)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER (0x0016)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP (0x0017)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP (0x0018)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP (0x0019)
#define JDKSAVDECC_DESCRIPTOR_CONTROL (0x001a)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR (0x001b)
#define JDKSAVDECC_DESCRIPTOR_MIXER (0x001c)
#define JDKSAVDECC_DESCRIPTOR_MATRIX (0x001d)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL (0x001e)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER (0x001f)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER (0x0020)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER (0x0021)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER (0x0022)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_TRANSCODER (0x0023)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN (0x0024)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK (0x0025)
#define JDKSAVDECC_DESCRIPTOR_INVALID (0xffff)

#define JDKSAVDECC_NUM_DESCRIPTOR_TYPES (0x0026)
/*@}*/

/** \addtogroup jack_type jack_type : Jack Types - Clause 7.2.7.2  */
/*@{*/

#define JDKSAVDECC_JACK_TYPE_SPEAKER (0x0000)
#define JDKSAVDECC_JACK_TYPE_HEADPHONE (0x0001)
#define JDKSAVDECC_JACK_TYPE_ANALOG_MICROPHONE (0x0002)
#define JDKSAVDECC_JACK_TYPE_SPDIF (0x0003)
#define JDKSAVDECC_JACK_TYPE_ADAT (0x0004)
#define JDKSAVDECC_JACK_TYPE_TDIF (0x0005)
#define JDKSAVDECC_JACK_TYPE_MADI (0x0006)
#define JDKSAVDECC_JACK_TYPE_UNBALANCED_ANALOG (0x0007)
#define JDKSAVDECC_JACK_TYPE_BALANCED_ANALOG (0x0008)
#define JDKSAVDECC_JACK_TYPE_DIGITAL (0x0009)
#define JDKSAVDECC_JACK_TYPE_MIDI (0x000a)
#define JDKSAVDECC_JACK_TYPE_AES_EBU (0x000b)
#define JDKSAVDECC_JACK_TYPE_COMPOSITE_VIDEO (0x000c)
#define JDKSAVDECC_JACK_TYPE_S_VHS_VIDEO (0x000d)
#define JDKSAVDECC_JACK_TYPE_COMPONENT_VIDEO (0x000e)
#define JDKSAVDECC_JACK_TYPE_DVI (0x000f)
#define JDKSAVDECC_JACK_TYPE_HDMI (0x0010)
#define JDKSAVDECC_JACK_TYPE_UDI (0x0011)
#define JDKSAVDECC_JACK_TYPE_DISPLAYPORT (0x0012)
#define JDKSAVDECC_JACK_TYPE_ANTENNA (0x0013)
#define JDKSAVDECC_JACK_TYPE_ANALOG_TUNER (0x0014)
#define JDKSAVDECC_JACK_TYPE_ETHERNET (0x0015)
#define JDKSAVDECC_JACK_TYPE_WIFI (0x0016)
#define JDKSAVDECC_JACK_TYPE_USB (0x0017)
#define JDKSAVDECC_JACK_TYPE_PCI (0x0018)
#define JDKSAVDECC_JACK_TYPE_PCI_E (0x0019)
#define JDKSAVDECC_JACK_TYPE_SCSI (0x001a)
#define JDKSAVDECC_JACK_TYPE_ATA (0x001b)
#define JDKSAVDECC_JACK_TYPE_IMAGER (0x001c)
#define JDKSAVDECC_JACK_TYPE_IR (0x001d)
#define JDKSAVDECC_JACK_TYPE_THUNDERBOLT (0x001e)
#define JDKSAVDECC_JACK_TYPE_SATA (0x001f)
#define JDKSAVDECC_JACK_TYPE_SMPTE_LTC (0x0020)
#define JDKSAVDECC_JACK_TYPE_DIGITAL_MICROPHONE (0x0021)
#define JDKSAVDECC_JACK_TYPE_EXPANSION (0xffff)

/*@}*/

/** \addtogroup clock_source_type clock_source_type : CLOCK_SOURCE Types -
 * Clause 7.2.9.2  */
/*@{*/

#define JDKSAVDECC_CLOCK_SOURCE_TYPE_INTERNAL (0x0000)
#define JDKSAVDECC_CLOCK_SOURCE_TYPE_EXTERNAL (0x0001)
#define JDKSAVDECC_CLOCK_SOURCE_TYPE_INPUT_STREAM (0x0002)
#define JDKSAVDECC_CLOCK_SOURCE_TYPE_MEDIA_CLOCK_STREAM (0x0003)
#define JDKSAVDECC_CLOCK_SOURCE_TYPE_EXPANSION (0xffff)

/*@}*/

/** \addtogroup memory_object_type memory_object_type : Memory Object Types -
 * Clause 7.2.10.1  */
/*@{*/

#define JDKSAVDECC_MEMORY_OBJECT_TYPE_FIRMWARE_IMAGE (0x0000)
#define JDKSAVDECC_MEMORY_OBJECT_TYPE_VENDOR_SPECIFIC (0x0001)
#define JDKSAVDECC_MEMORY_OBJECT_TYPE_CRASH_DUMP (0x0002)
#define JDKSAVDECC_MEMORY_OBJECT_TYPE_LOG_OBJECT (0x0003)
#define JDKSAVDECC_MEMORY_OBJECT_TYPE_AUTOSTART_SETTINGS (0x0004)
#define JDKSAVDECC_MEMORY_OBJECT_TYPE_SNAPSHOT_SETTINGS (0x0005)

/*@}*/

/** \addtogroup memory_object_operation memory_object_operation : MEMORY_OBJECT
 * Operation Types - Clause 7.2.10.2  */
/*@{*/

#define JDKSAVDECC_MEMORY_OBJECT_OPERATION_STORE (0x0000)
#define JDKSAVDECC_MEMORY_OBJECT_OPERATION_STORE_AND_REBOOT (0x0001)
#define JDKSAVDECC_MEMORY_OBJECT_OPERATION_READ (0x0002)
#define JDKSAVDECC_MEMORY_OBJECT_OPERATION_ERASE (0x0003)
#define JDKSAVDECC_MEMORY_OBJECT_OPERATION_UPLOAD (0x0004)

/*@}*/

/** \addtogroup audio_cluster_format audio_cluster_format : AUDIO_CLUSTER format
 * values - Clause 7.2.16.1  */
/*@{*/

#define JDKSAVDECC_AUDIO_CLUSTER_FORMAT_IEC_60958 (0x00)
#define JDKSAVDECC_AUDIO_CLUSTER_FORMAT_MBLA (0x40)
#define JDKSAVDECC_AUDIO_CLUSTER_FORMAT_MIDI (0x80)
#define JDKSAVDECC_AUDIO_CLUSTER_FORMAT_SMPTE (0x88)

/*@}*/

/** \addtogroup video_cluster_format video_cluster_format : VIDEO_CLUSTER format
 * values - Clause 7.2.17.1  */
/*@{*/

#define JDKSAVDECC_VIDEO_CLUSTER_FORMAT_MPEG_PES_FORMAT (0x00)
#define JDKSAVDECC_VIDEO_CLUSTER_FORMAT_AVTP_FORMAT (0x01)
#define JDKSAVDECC_VIDEO_CLUSTER_FORMAT_RTP_PAYLOAD_FORMAT (0x02)
#define JDKSAVDECC_VIDEO_CLUSTER_FORMAT_VENDOR_SPECIFIC_FORMAT (0xfe)
#define JDKSAVDECC_VIDEO_CLUSTER_FORMAT_EXPERIMENTAL_FORMAT (0xff)

/*@}*/

/** \addtogroup src_mode_options src_mode_options : SRC Mode Selection Options -
 * Clause 7.3.4.8  */
/*@{*/

#define JDKSAVDECC_SRC_MODE_OPTIONS_OFF (0x00)
#define JDKSAVDECC_SRC_MODE_OPTIONS_SYNCHRONOUS (0x01)
#define JDKSAVDECC_SRC_MODE_OPTIONS_ASYNCHRONOUS (0x02)

/*@}*/

/** \addtogroup snapshot_operation snapshot_operation : SNAPSHOT Operation Types
 * - Clause 7.3.4.9  */
/*@{*/

#define JDKSAVDECC_SNAPSHOT_OPERATION_CAPTURE (0x0000)
#define JDKSAVDECC_SNAPSHOT_OPERATION_RECALL (0x0001)
#define JDKSAVDECC_SNAPSHOT_OPERATION_ERASE (0x0002)

/*@}*/

/** \addtogroup auto_exposure auto_exposure : Auto Exposure Modes - Clause
 * 7.3.4.27  */
/*@{*/

#define JDKSAVDECC_AUTO_EXPOSURE_MANUAL (0x0)
#define JDKSAVDECC_AUTO_EXPOSURE_AUTO (0x1)
#define JDKSAVDECC_AUTO_EXPOSURE_SHUTTER_PRIO (0x2)
#define JDKSAVDECC_AUTO_EXPOSURE_APER_PRIO (0x3)

/*@}*/

/** \addtogroup media_disk_operation media_disk_operation : Operation type codes
 * for the MEDIA_DISK control - Clause 7.3.4.49  */
/*@{*/

#define JDKSAVDECC_MEDIA_DISK_OPERATION_CHOOSE (0x0000)
#define JDKSAVDECC_MEDIA_DISK_OPERATION_PREVIOUS (0x0001)
#define JDKSAVDECC_MEDIA_DISK_OPERATION_NEXT (0x0002)
#define JDKSAVDECC_MEDIA_DISK_OPERATION_OPEN (0x0003)
#define JDKSAVDECC_MEDIA_DISK_OPERATION_CLOSE (0x0004)

/*@}*/

/** \addtogroup media_record_transport_operation
 * media_record_transport_operation : Operation type codes for the
 * MEDIA_RECORD_TRANSPORT control - Clause 7.3.4.56  */
/*@{*/

#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_STOP (0x0000)
#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_PLAY (0x0001)
#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_PAUSE (0x0002)
#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_UNPAUSE (0x0003)
#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_SCAN_FORWARD (0x0004)
#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_SCAN_BACKWARD (0x0005)
#define JDKSAVDECC_MEDIA_RECORD_TRANSPORT_OPERATION_RECORD (0x0006)

/*@}*/

/** \addtogroup modulation modulation : Modulation Selection Options - Clause
 * 7.3.4.58  */
/*@{*/

#define JDKSAVDECC_MODULATION_AMPLITUDE_MODULATION (0x00)
#define JDKSAVDECC_MODULATION_FREQUENCY_MODULATION (0x01)
#define JDKSAVDECC_MODULATION_PHASE_MODULATION (0x02)

/*@}*/

/** \addtogroup polarization polarization : Polarization Selection Options -
 * Clause 7.3.4.59  */
/*@{*/

#define JDKSAVDECC_POLARIZATION_VERTICAL (0x00)
#define JDKSAVDECC_POLARIZATION_HORIZONTAL (0x01)
#define JDKSAVDECC_POLARIZATION_LEFT_HAND_CIRCULAR (0x02)
#define JDKSAVDECC_POLARIZATION_RIGHT_HAND_CIRCULAR (0x03)

/*@}*/

/** \addtogroup values_type values_type : Value Types - Clause 7.3.5.1.3  */
/*@{*/

#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_INT8 (0x0000)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_UINT8 (0x0001)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_INT16 (0x0002)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_UINT16 (0x0003)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_INT32 (0x0004)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_UINT32 (0x0005)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_INT64 (0x0006)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_UINT64 (0x0007)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_FLOAT (0x0008)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_LINEAR_DOUBLE (0x0009)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_INT8 (0x000a)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_UINT8 (0x000b)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_INT16 (0x000c)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_UINT16 (0x000d)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_INT32 (0x000e)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_UINT32 (0x000f)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_INT64 (0x0010)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_UINT64 (0x0011)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_FLOAT (0x0012)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_DOUBLE (0x0013)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SELECTOR_STRING (0x0014)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_INT8 (0x0015)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_UINT8 (0x0016)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_INT16 (0x0017)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_UINT16 (0x0018)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_INT32 (0x0019)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_UINT32 (0x001a)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_INT64 (0x001b)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_UINT64 (0x001c)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_FLOAT (0x001d)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_ARRAY_DOUBLE (0x001e)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_UTF8 (0x001f)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_BODE_PLOT (0x0020)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SMPTE_TIME (0x0021)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_SAMPLE_RATE (0x0022)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_GPTP_TIME (0x0023)
#define JDKSAVDECC_VALUES_TYPE_CONTROL_VENDOR (0x3ffe)
#define JDKSAVDECC_VALUES_TYPE_EXPANSION (0x3fff)

/*@}*/

/** \addtogroup mpeg_pes_cp mpeg_pes_cp : Format Specific cp subfield values -
 * Clause 7.3.7.1.1  */
/*@{*/

#define JDKSAVDECC_MPEG_PES_CP_NONE (0x0)
#define JDKSAVDECC_MPEG_PES_CP_HDCP (0x1)
#define JDKSAVDECC_MPEG_PES_CP_DTCP (0x2)
#define JDKSAVDECC_MPEG_PES_CP_AES_ENCRYPTION (0x3)

/*@}*/

/** \addtogroup mpeg_pes_profile mpeg_pes_profile : MPEG_PES_FORMAT profile
 * subfield values - Clause 7.3.7.2.1  */
/*@{*/

#define JDKSAVDECC_MPEG_PES_PROFILE_H264_CBP (0x00)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_BP (0x01)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_MP (0x02)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_XP (0x03)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HIP (0x04)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_PHIP (0x05)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HI10P (0x06)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HI422P (0x07)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HI444PP (0x08)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HI10I (0x09)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HI422I (0x0a)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_HI444I (0x0b)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_CAVLC44I (0x0c)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_SBP (0x0d)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_SHP (0x0e)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_SHI (0x0f)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_STHP (0x10)
#define JDKSAVDECC_MPEG_PES_PROFILE_H264_MVHP (0x11)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_SP (0x12)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_MP (0x13)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_SNR (0x14)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_SPATIAL (0x15)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_HP (0x16)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_422 (0x17)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_MVP (0x18)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG1_LAYER2 (0x80)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG1_LAYER3 (0x81)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_LAYER2 (0x82)
#define JDKSAVDECC_MPEG_PES_PROFILE_MPEG2_LAYER3 (0x83)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_DIGITAL (0x84)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_DIGITAL_PLUS (0x85)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_DIGITAL_TRUEHD (0x86)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_PRO_LOGIC_II (0x87)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_DIGITAL_EX (0x88)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_DIGITAL_SURROUND_EX (0x89)
#define JDKSAVDECC_MPEG_PES_PROFILE_DOLBY_DIGITAL_LIVE (0x8a)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_5_1 (0x8b)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_ES_MATRIX (0x8c)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_ES_DISCRETE (0x8d)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_NEO_6 (0x8e)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_NEO_X (0x8f)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_96_24 (0x90)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_HD (0x91)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_HD_MASTER (0x92)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_INTERACTIVE (0x93)
#define JDKSAVDECC_MPEG_PES_PROFILE_DTS_NEO_PC (0x94)
#define JDKSAVDECC_MPEG_PES_PROFILE_AAC_LC (0x95)
#define JDKSAVDECC_MPEG_PES_PROFILE_AAC_MAIN (0x96)
#define JDKSAVDECC_MPEG_PES_PROFILE_AAC_LD (0x97)
#define JDKSAVDECC_MPEG_PES_PROFILE_AAC_HE (0x98)
#define JDKSAVDECC_MPEG_PES_PROFILE_AAC_HE2 (0x99)

/*@}*/

/** \addtogroup mpeg_pes_h264_level mpeg_pes_h264_level : MPEG_PES_FORMAT H.264
 * Profile level subfield values - Clause 7.3.7.2.2.1
 */
/*@{*/

#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_1 (0x00)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_1B (0x01)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_1_1 (0x02)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_1_2 (0x03)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_1_3 (0x01)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_2 (0x05)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_2_1 (0x06)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_2_2 (0x07)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_3 (0x08)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_3_1 (0x09)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_3_2 (0x0a)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_4 (0x0b)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_4_1 (0x0c)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_4_2 (0x0d)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_5 (0x0e)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_5_1 (0x0f)
#define JDKSAVDECC_MPEG_PES_H264_LEVEL_H264_5_2 (0x10)

/*@}*/

/** \addtogroup mpeg_pes_compressed_audio_sample_rate
 * mpeg_pes_compressed_audio_sample_rate : MPEG_PES_FORMAT Compressed Audio
 * sample rates - Clause 7.3.7.2.3  */
/*@{*/

#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_8K (0x0)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_16K (0x1)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_22K05 (0x2)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_24K (0x3)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_32K (0x4)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_44K1 (0x5)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_48K (0x6)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_96K (0x7)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_SAMPLE_RATE_192K (0x8)

/*@}*/

/** \addtogroup mpeg_pes_compressed_audio mpeg_pes_compressed_audio :
 * MPEG_PES_FORMAT Compressed Audio channel options - Clause
 * 7.3.7.2.3  */
/*@{*/

#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_MONO (0x00)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_STEREO (0x01)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_STEREO_JOINED (0x02)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_DUAL_CHANNEL (0x03)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_2_1 (0x04)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_3_0 (0x05)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_3_1 (0x06)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_4_0 (0x07)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_4_1 (0x08)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_5_0 (0x09)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_5_1 (0x0a)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_6_0 (0x0b)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_6_1 (0x0c)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_7_0 (0x0d)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_7_1 (0x0e)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_8_0 (0x0f)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_10_1 (0x10)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_OTHER (0x1f)

/*@}*/

/** \addtogroup mpeg_pes_compressed_audio_bitrate
 * mpeg_pes_compressed_audio_bitrate : MPEG_PES_FORMAT Compressed Audio bitrates
 * -
 * Clause 7.3.7.2.3  */
/*@{*/

#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_VARIABLE_BIT_RATE (0x00)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_16_KBPS (0x01)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_24_KBPS (0x02)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_32_KBPS (0x03)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_40_KBPS (0x01)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_48_KBPS (0x05)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_56_KBPS (0x06)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_64_KBPS (0x07)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_80_KBPS (0x08)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_96_KBPS (0x09)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_112_KBPS (0x0a)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_128_KBPS (0x0b)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_144_KBPS (0x0c)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_160_KBPS (0x0d)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_192_KBPS (0x0e)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_224_KBPS (0x0f)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_256_KBPS (0x10)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_288_KBPS (0x11)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_320_KBPS (0x12)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_352_KBPS (0x13)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_384_KBPS (0x14)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_RESERVED_FOR_FUTURE_USE_ (0x15)
#define JDKSAVDECC_MPEG_PES_COMPRESSED_AUDIO_BITRATE_OTHER__DECODE_FROM_STREAM_ (0x7f)

/*@}*/

/** \addtogroup rtp_payload_subtype rtp_payload_subtype : RTP Payload Subtypes
 * subfield values - Clause 7.3.7.4.1  */
/*@{*/

#define JDKSAVDECC_RTP_PAYLOAD_SUBTYPE_RTP_MJPEG (0x0000)
#define JDKSAVDECC_RTP_PAYLOAD_SUBTYPE_RTP_H264 (0x0001)
#define JDKSAVDECC_RTP_PAYLOAD_SUBTYPE_RTP_JPEG200 (0x0002)

/*@}*/

/** \addtogroup video_cluster_color_space video_cluster_color_space : Video
 * Cluster Color Spaces - Clause 7.3.10  */
/*@{*/

#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_MONO8 (0x0000)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_MONO12_PACKED (0x0001)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_MONO16 (0x0002)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_MONO16_SIGNED (0x0003)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_YUV411_PACKED (0x0004)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_YUV422_PACKED (0x0005)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_YUV444_PACKED (0x0006)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_RGB_PACKED (0x0007)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_RGB16 (0x0008)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_RGB16_SIGNED (0x0009)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERGR8 (0x000a)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERGR12_PACKED (0x000b)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERGR16 (0x000c)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERRG8 (0x000d)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERRG12_PACKED (0x000e)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERRG16 (0x000f)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERGB8 (0x0010)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERGB12_PACKED (0x0011)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERGB16 (0x0012)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERBG8 (0x0013)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERBG12_PACKED (0x0014)
#define JDKSAVDECC_VIDEO_CLUSTER_COLOR_SPACE_BAYERBG16 (0x0015)

/*@}*/

/** \addtogroup control_type control_type : Control Types - Clause 7.3.4  */
/*@{*/
#define JDKSAVDECC_AEM_CONTROL_TYPE_ENABLE 0x90e0f00000000000ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_IDENTIFY 0x90e0f00000000001ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MUTE 0x90e0f00000000002ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_INVERT 0x90e0f00000000003ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_GAIN 0x90e0f00000000004ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_ATTENUATE 0x90e0f00000000005ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_DELAY 0x90e0f00000000006ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_SRC_MODE 0x90e0f00000000007ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_SNAPSHOT 0x90e0f00000000008ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_POW_LINE_FREQ 0x90e0f00000000009ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_POWER_STATUS 0x90e0f0000000000aULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_FAN_STATUS 0x90e0f0000000000bULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_TEMPERATURE 0x90e0f0000000000cULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_ALTITUDE 0x90e0f0000000000dULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_ABSOLUTE_HUMIDITY 0x90e0f0000000000eULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_RELATIVE_HUMIDITY 0x90e0f0000000000fULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_ORIENTATION 0x90e0f00000000010ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_VELOCITY 0x90e0f00000000011ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_ACCELERATION 0x90e0f00000000012ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_FILTER_RESPONSE 0x90e0f00000000013ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_PANPOT 0x90e0f00000010000ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_PHANTOM 0x90e0f00000100001ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_AUDIO_SCALE 0x90e0f00000100002ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_AUDIO_METERS 0x90e0f00000100003ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_AUDIO_SPECTRUM 0x90e0f00000100004ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_SCANNING_MODE 0x90e0f00000200000ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_AUTO_EXP_MODE 0x90e0f00000200001ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_AUTO_EXP_PRIO 0x90e0f00000200002ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_EXP_TIME 0x90e0f00000200003ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_FOCUS 0x90e0f00000200004ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_FOCUS_AUTO 0x90e0f00000200005ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_IRIS 0x90e0f00000200006ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_ZOOM 0x90e0f00000200007ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_PRIVACY 0x90e0f00000200008ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_BACKLIGHT 0x90e0f00000200009ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_BRIGHTNESS 0x90e0f0000020000aULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_CONTRAST 0x90e0f0000020000bULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_HUE 0x90e0f0000020000cULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_SATURATION 0x90e0f0000020000dULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_SHARPNESS 0x90e0f0000020000eULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_GAMMA 0x90e0f0000020000fULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_WHITE_BAL_TEMP 0x90e0f00000200010ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_WHITE_BAL_TEMP_AUTO 0x90e0f00000200011ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_WHITE_BAL_COMP 0x90e0f00000200012ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_WHITE_BAL_COMP_AUTO 0x90e0f00000200013ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_DIGITAL_ZOOM 0x90e0f00000200014ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_PLAYLIST 0x90e0f00000300000ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_PLAYLIST_NAME 0x90e0f00000300001ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_DISK 0x90e0f00000300002ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_DISK_NAME 0x90e0f00000300003ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_TRACK 0x90e0f00000300004ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_TRACK_NAME 0x90e0f00000300005ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_SPEED 0x90e0f00000300006ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_SAMPLE_POSITION 0x90e0f00000300007ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_PLAYBACK_TRANSPORT 0x90e0f00000300008ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MEDIA_RECORD_TRANSPORT 0x90e0f00000300009ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_FREQUENCY 0x90e0f00000400000ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_MODULATION 0x90e0f00000400001ULL
#define JDKSAVDECC_AEM_CONTROL_TYPE_POLARIZATION 0x90e0f00000400002ULL

/*@}*/

/** \addtogroup units Units */
/*@{*/

#define JDKSAVDECC_AEM_UNIT_UNITLESS (0x00)
#define JDKSAVDECC_AEM_UNIT_COUNT (0x01)
#define JDKSAVDECC_AEM_UNIT_PERCENT (0x02)
#define JDKSAVDECC_AEM_UNIT_FSTOP (0x03)
#define JDKSAVDECC_AEM_UNIT_TIME_SECONDS (0x08)
#define JDKSAVDECC_AEM_UNIT_TIME_MINUTES (0x09)
#define JDKSAVDECC_AEM_UNIT_TIME_HOURS (0x0a)
#define JDKSAVDECC_AEM_UNIT_TIME_DAYS (0x0b)
#define JDKSAVDECC_AEM_UNIT_TIME_MONTHS (0x0c)
#define JDKSAVDECC_AEM_UNIT_TIME_YEARS (0x0d)
#define JDKSAVDECC_AEM_UNIT_TIME_SAMPLES (0x0e)
#define JDKSAVDECC_AEM_UNIT_TIME_FRAMES (0x0f)
#define JDKSAVDECC_AEM_UNIT_FREQUENCY_HERTZ (0x10)
#define JDKSAVDECC_AEM_UNIT_FREQUENCY_SEMITONES (0x11)
#define JDKSAVDECC_AEM_UNIT_FREQUENCY_CENTS (0x12)
#define JDKSAVDECC_AEM_UNIT_FREQUENCY_OCTAVES (0x13)
#define JDKSAVDECC_AEM_UNIT_FREQUENCY_FPS (0x14)
#define JDKSAVDECC_AEM_UNIT_DISTANCE_METRES (0x18)
#define JDKSAVDECC_AEM_UNIT_TEMPERATURE_KELVIN (0x20)
#define JDKSAVDECC_AEM_UNIT_MASS_GRAMS (0x28)
#define JDKSAVDECC_AEM_UNIT_VOLTAGE_VOLTS (0x30)
#define JDKSAVDECC_AEM_UNIT_VOLTAGE_DBV (0x31)
#define JDKSAVDECC_AEM_UNIT_VOLTAGE_DBU (0x32)
#define JDKSAVDECC_AEM_UNIT_CURRENT_AMPS (0x38)
#define JDKSAVDECC_AEM_UNIT_POWER_WATTS (0x40)
#define JDKSAVDECC_AEM_UNIT_POWER_DBM (0x41)
#define JDKSAVDECC_AEM_UNIT_POWER_DBW (0x42)
#define JDKSAVDECC_AEM_UNIT_PRESSURE_PASCALS (0x48)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BITS (0x50)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BYTES (0x51)
#define JDKSAVDECC_AEM_UNIT_MEMORY_KIBIBYTES (0x52)
#define JDKSAVDECC_AEM_UNIT_MEMORY_MEBIBYTES (0x53)
#define JDKSAVDECC_AEM_UNIT_MEMORY_GIBIBYTES (0x54)
#define JDKSAVDECC_AEM_UNIT_MEMORY_TEBIBYTES (0x55)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BANDWIDTH_BITS_PER_SEC (0x58)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BANDWIDTH_BYTES_PER_SEC (0x59)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BANDWIDTH_KIBIBYTES_PER_SEC (0x5a)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BANDWIDTH_MEBIBYTES_PER_SEC (0x5b)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BANDWIDTH_GIGIBYTES_PER_SEC (0x5c)
#define JDKSAVDECC_AEM_UNIT_MEMORY_BANDWIDTH_TEBIBYTES_PER_SEC (0x5d)
#define JDKSAVDECC_AEM_UNIT_LUMINOSITY_CANDELAS (0x60)
#define JDKSAVDECC_AEM_UNIT_ENERGY_JOULES (0x68)
#define JDKSAVDECC_AEM_UNIT_ANGLE_RADIANS (0x70)
#define JDKSAVDECC_AEM_UNIT_FORCE_NEWTONS (0x78)
#define JDKSAVDECC_AEM_UNIT_RESISTANCE_OHMS (0x80)
#define JDKSAVDECC_AEM_UNIT_VELOCITY_METRES_PER_SEC (0x88)
#define JDKSAVDECC_AEM_UNIT_VELOCITY_RADIANS_PER_SEC (0x89)
#define JDKSAVDECC_AEM_UNIT_ACCELERATION_METRES_PER_SEC_SQUARED (0x90)
#define JDKSAVDECC_AEM_UNIT_ACCELERATION_RADIANS_PER_SEC_SQUARED (0x91)
#define JDKSAVDECC_AEM_UNIT_MAGNETIC_FLUX_TESLAS (0x98)
#define JDKSAVDECC_AEM_UNIT_AREA_METERS_SQUARED (0xa0)
#define JDKSAVDECC_AEM_UNIT_VOLUME_METERS_CUBED (0xa8)
#define JDKSAVDECC_AEM_UNIT_VOLUME_LITRES (0xa9)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB (0xb0)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB_PEAK (0xb1)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB_RMS (0xb2)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DBFS (0xb3)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DBFS_PEAK (0xb4)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DBFS_RMS (0xb5)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DBTP (0xb6)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB_A (0xb7)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB_B (0xb8)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB_C (0xb9)
#define JDKSAVDECC_AEM_UNIT_LEVEL_DB_SPL (0xba)
#define JDKSAVDECC_AEM_UNIT_LEVEL_LU (0xbb)
#define JDKSAVDECC_AEM_UNIT_LEVEL_LUFS (0xbc)

/*@}*/

/** \addtogroup pull Sample Rate Pull field - See Clause 7.3.1.1 */
/*@{*/

#define JDKSAVDECC_AEM_SAMPLE_RATE_PULL_MULTIPLY_1 (0x0)
#define JDKSAVDECC_AEM_SAMPLE_RATE_PULL_MULTIPLY_1_DIV_1_001 (0x1)
#define JDKSAVDECC_AEM_SAMPLE_RATE_PULL_MULTIPLY_1_001 (0x2)
#define JDKSAVDECC_AEM_SAMPLE_RATE_PULL_MULTIPLY_24_DIV_25 (0x3)
#define JDKSAVDECC_AEM_SAMPLE_RATE_PULL_MULTIPLY_25_DIV_24 (0x4)

/*@}*/

/** \addtogroup audio_mapping Audio Mappings Format - Clause 7.2.19.1  */
/*@{*/

#define JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_STREAM_INDEX (0)
#define JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_STREAM_CHANNEL (2)
#define JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_CLUSTER_OFFSET (4)
#define JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_CLUSTER_CHANNEL (6)
#define JDKSAVDECC_AUDIO_MAPPING_LEN (8)

/*@}*/

/** \addtogroup video_mapping Video Mappings Format - Clause 7.2.20.1  */
/*@{*/

#define JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_STREAM_INDEX (0)
#define JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_PROGRAM_STREAM (2)
#define JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_ELEMENTARY_STREAM (4)
#define JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_CLUSTER_OFFSET (6)
#define JDKSAVDECC_VIDEO_MAPPING_LEN (8)

/*@}*/

/** \addtogroup signal_selector_source Signal Selector Sources Field - Clause
 * 7.2.23.1  */
/*@{*/

#define JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_TYPE (0)
#define JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_INDEX (2)
#define JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_OUTPUT (4)
#define JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_LEN (6)

/*@}*/

/** \addtogroup mixer_source Mixer Sources Field - Clause 7.2.24.1  */
/*@{*/

#define JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_TYPE (0)
#define JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_INDEX (2)
#define JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_OUTPUT (4)
#define JDKSAVDECC_MIXER_SOURCE_LEN (6)

/*@}*/

/** \addtogroup splitter_map splitter_map Format - Clause 7.2.27.1  */
/*@{*/

#define JDKSAVDECC_SPLITTER_MAP_OFFSET_SUB_SIGNAL_START (0)
#define JDKSAVDECC_SPLITTER_MAP_OFFSET_SUB_SIGNAL_COUNT (2)
#define JDKSAVDECC_SPLITTER_MAP_OFFSET_OUTPUT_INDEX (4)
#define JDKSAVDECC_SPLITTER_MAP_LEN (6)

/*@}*/

/** \addtogroup combiner_map combiner_map Format - Clause 7.2.28.1  */
/*@{*/

#define JDKSAVDECC_COMBINER_MAP_OFFSET_SUB_SIGNAL_START (0)
#define JDKSAVDECC_COMBINER_MAP_OFFSET_SUB_SIGNAL_COUNT (2)
#define JDKSAVDECC_COMBINER_MAP_OFFSET_INPUT_INDEX (4)
#define JDKSAVDECC_COMBINER_MAP_LEN (6)

/*@}*/

/** \addtogroup demultiplexer_map demultiplexer_map Format - Clause 7.2.29.1  */
/*@{*/

#define JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_SUB_SIGNAL_START (0)
#define JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_SUB_SIGNAL_COUNT (2)
#define JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_OUTPUT_INDEX (4)
#define JDKSAVDECC_DEMULTIPLEXER_MAP_LEN (6)

/*@}*/

/** \addtogroup multiplexer_source Signal Multiplexer Sources Field - Clause
 * 7.2.30.2  */
/*@{*/

#define JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_TYPE (0)
#define JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_INDEX (2)
#define JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_OUTPUT (4)
#define JDKSAVDECC_MULTIPLEXER_SOURCE_LEN (6)

/*@}*/

/** \addtogroup values_bode_plot Bode Plot Value Details - Clause 7.3.5.2.5  */
/*@{*/

#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_MINIMUM (0)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_MAXIMUM (4)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_STEP (8)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_DEFAULT (12)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_MINIMUM (16)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_MAXIMUM (20)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_STEP (24)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_DEFAULT (28)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_MINIMUM (32)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_MAXIMUM (36)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_STEP (40)
#define JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_DEFAULT (44)
#define JDKSAVDECC_VALUES_BODE_PLOT_LEN (48)

/*@}*/

/** \addtogroup values_smpte_time SMPTE Value Details - Clause 7.3.5.2.6  */
/*@{*/

#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_HOURS (0)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_MINUTES (2)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_SECONDS (3)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_FRAMES (4)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_SUBFRAMES (5)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_FRAMES_PER_SECOND (7)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_DROP_FRAME (8)
#define JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_PULL (9)
#define JDKSAVDECC_VALUES_SMPTE_TIME_LEN (10)

/*@}*/

/** \addtogroup values_sample_rate Sample Rate Value Details - Clause 7.3.5.2.7
 */
/*@{*/

#define JDKSAVDECC_VALUES_SAMPLE_RATE_OFFSET_SAMPLE_RATE (0)
#define JDKSAVDECC_VALUES_SAMPLE_RATE_LEN (4)

/*@}*/

/** \addtogroup values_gptp_time gPTP Time Value Details - Clause 7.3.5.2.8  */
/*@{*/

#define JDKSAVDECC_VALUES_GPTP_TIME_OFFSET_GPTP_SECONDS (0)
#define JDKSAVDECC_VALUES_GPTP_TIME_OFFSET_GPTP_NANOSECONDS (6)
#define JDKSAVDECC_VALUES_GPTP_TIME_LEN (10)

/*@}*/

/** \addtogroup values_vendor Vendor Value Details - Clause 7.3.5.2.9  */
/*@{*/

#define JDKSAVDECC_VALUES_VENDOR_OFFSET_VENDOR_EUI64 (0)
#define JDKSAVDECC_VALUES_VENDOR_OFFSET_BLOB_SIZE (8)
#define JDKSAVDECC_VALUES_VENDOR_OFFSET_BINARY_BLOB (12)
#define JDKSAVDECC_VALUES_VENDOR_LEN (12)

/*@}*/

/** \addtogroup msrp_mappings_format msrp_mappings Format - Clause 7.4.40.2.1
 */
/*@{*/

#define JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_TRAFFIC_CLASS (0)
#define JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_PRIORITY (1)
#define JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_VLAN_ID (2)
#define JDKSAVDECC_MSRP_MAPPINGS_FORMAT_LEN (4)

/*@}*/

/** \addtogroup audio_mappings_format Audio Mappings Format - Clause 7.4.44.2.1
 */
/*@{*/

#define JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_INDEX (0)
#define JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_CHANNEL (2)
#define JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_OFFSET (4)
#define JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_CHANNEL (6)
#define JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_LEN (8)

/*@}*/

/** \addtogroup video_mappings_format Video Mappings Format - Clause 7.4.47.2.1
 */
/*@{*/

#define JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_INDEX (0)
#define JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_PROGRAM_STREAM (2)
#define JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_ELEMENTARY_STREAM (4)
#define JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_OFFSET (6)
#define JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_LEN (8)

/*@}*/

/** \addtogroup descriptor_entity ENTITY Descriptor - Clause 7.2.1  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_ENTITY_ID (4)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_VENDOR_ID (12)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_MODEL_ID (16)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_CAPABILITIES (20)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_TALKER_STREAM_SOURCES (24)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_TALKER_CAPABILITIES (26)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_LISTENER_STREAM_SINKS (28)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_LISTENER_CAPABILITIES (30)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CONTROLLER_CAPABILITIES (32)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_AVAILABLE_INDEX (36)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ASSOCIATION_ID (40)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_NAME (48)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_VENDOR_NAME_STRING (112)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_MODEL_NAME_STRING (114)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_FIRMWARE_VERSION (116)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_GROUP_NAME (180)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_SERIAL_NUMBER (244)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CONFIGURATIONS_COUNT (308)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CURRENT_CONFIGURATION (310)
#define JDKSAVDECC_DESCRIPTOR_ENTITY_LEN (312)

/*@}*/

/** \addtogroup descriptor_configuration CONFIGURATION Descriptor - Clause 7.2.2
 */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS_COUNT (70)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS_OFFSET (72)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS (74)
#define JDKSAVDECC_DESCRIPTOR_CONFIGURATION_LEN (74)

/*@}*/

/** \addtogroup descriptor_audio AUDIO_UNIT Descriptor - Clause 7.2.3  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_CLOCK_DOMAIN_INDEX (70)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS (72)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_STREAM_INPUT_PORT (74)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS (76)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_STREAM_OUTPUT_PORT (78)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS (80)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_EXTERNAL_INPUT_PORT (82)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS (84)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_EXTERNAL_OUTPUT_PORT (86)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS (88)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_INTERNAL_INPUT_PORT (90)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS (92)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_INTERNAL_OUTPUT_PORT (94)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_CONTROLS (96)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_CONTROL (98)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_SIGNAL_SELECTORS (100)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_SIGNAL_SELECTOR (102)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MIXERS (104)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MIXER (106)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MATRICES (108)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MATRIX (110)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_SPLITTERS (112)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_SPLITTER (114)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_COMBINERS (116)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_COMBINER (118)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_DEMULTIPLEXERS (120)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_DEMULTIPLEXER (122)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MULTIPLEXERS (124)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MULTIPLEXER (126)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_TRANSCODERS (128)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_TRANSCODER (130)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_CONTROL_BLOCKS (132)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_CONTROL_BLOCK (134)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_CURRENT_SAMPLING_RATE (136)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES_OFFSET (140)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES_COUNT (142)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES (144)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_LEN (144)

/*@}*/

/** \addtogroup descriptor_video VIDEO_UNIT Descriptor - Clause 7.2.4  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_CLOCK_DOMAIN_INDEX (70)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS (72)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_STREAM_INPUT_PORT (74)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS (76)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_STREAM_OUTPUT_PORT (78)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS (80)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_EXTERNAL_INPUT_PORT (82)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS (84)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_EXTERNAL_OUTPUT_PORT (86)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS (88)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_INTERNAL_INPUT_PORT (90)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS (92)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_INTERNAL_OUTPUT_PORT (94)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_CONTROLS (96)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_CONTROL (98)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_SIGNAL_SELECTORS (100)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_SIGNAL_SELECTOR (102)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MIXERS (104)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MIXER (106)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MATRICES (108)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MATRIX (110)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_SPLITTERS (112)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_SPLITTER (114)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_COMBINERS (116)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_COMBINER (118)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_DEMULTIPLEXERS (120)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_DEMULTIPLEXER (122)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MULTIPLEXERS (124)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MULTIPLEXER (126)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_TRANSCODERS (128)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_TRANSCODER (130)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_CONTROL_BLOCKS (132)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_CONTROL_BLOCK (134)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_LEN (136)

/*@}*/

/** \addtogroup descriptor_sensor SENSOR_UNIT Descriptor - Clause 7.2.5  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_CLOCK_DOMAIN_INDEX (70)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS (72)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_STREAM_INPUT_PORT (74)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS (76)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_STREAM_OUTPUT_PORT (78)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS (80)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_EXTERNAL_INPUT_PORT (82)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS (84)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_EXTERNAL_OUTPUT_PORT (86)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS (88)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_INTERNAL_INPUT_PORT (90)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS (92)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_INTERNAL_OUTPUT_PORT (94)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_CONTROLS (96)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_CONTROL (98)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_SIGNAL_SELECTORS (100)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_SIGNAL_SELECTOR (102)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MIXERS (104)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MIXER (106)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MATRICES (108)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MATRIX (110)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_SPLITTERS (112)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_SPLITTER (114)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_COMBINERS (116)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_COMBINER (118)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_DEMULTIPLEXERS (120)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_DEMULTIPLEXER (122)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MULTIPLEXERS (124)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MULTIPLEXER (126)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_TRANSCODERS (128)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_TRANSCODER (130)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_CONTROL_BLOCKS (132)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_CONTROL_BLOCK (134)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_LEN (136)

/*@}*/

/** \addtogroup descriptor_stream STREAM_INPUT and STREAM_OUTPUT Descriptor -
 * Clause 7.2.6  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_CLOCK_DOMAIN_INDEX (70)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_STREAM_FLAGS (72)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_CURRENT_FORMAT (74)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_FORMATS_OFFSET (82)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_NUMBER_OF_FORMATS (84)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_0 (86)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_0 (94)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_1 (96)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_1 (104)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_2 (106)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_2 (114)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKEDUP_TALKER_ENTITY_ID (116)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKEDUP_TALKER_UNIQUE (124)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_AVB_INTERFACE_INDEX (126)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BUFFER_LENGTH (128)
#define JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_FORMATS (132)
#define JDKSAVDECC_DESCRIPTOR_STREAM_LEN (132)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLOCK_SYNC_SOURCE_BIT (15)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLOCK_SYNC_SOURCE (0x0001)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLOCK_SYNC_SOURCE_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLOCK_SYNC_SOURCE)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_A_BIT (14)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_A (0x0002)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_A_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_A)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_B_BIT (13)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_B (0x0004)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_B_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_CLASS_B)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SUPPORTS_ENCRYPTED_BIT (12)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SUPPORTS_ENCRYPTED (0x0008)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SUPPORTS_ENCRYPTED_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SUPPORTS_ENCRYPTED)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_SUPPORTED_BIT (11)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_SUPPORTED (0x0010)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_SUPPORTED_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_SUPPORTED)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_VALID_BIT (10)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_VALID (0x0020)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_VALID_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_PRIMARY_BACKUP_VALID)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_SUPPORTED_BIT (9)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_SUPPORTED (0x0040)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_SUPPORTED_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_SUPPORTED)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_VALID_BIT (8)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_VALID (0x0090)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_VALID_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_SECONDARY_BACKUP_VALID)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_SUPPORTED_BIT (7)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_SUPPORTED (0x0100)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_SUPPORTED_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_SUPPORTED)

#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_VALID_BIT (6)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_VALID (0x0200)
#define JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_VALID_MASK (~JDKSAVDECC_DESCRIPTOR_STREAM_FLAG_TERTIARY_BACKUP_VALID)

/*@}*/

/** \addtogroup descriptor_jack JACK_INPUT and JACK_OUTPUT Descriptor - Clause
 * 7.2.7  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_JACK_FLAGS (70)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_JACK_TYPE (72)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_NUMBER_OF_CONTROLS (74)
#define JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_BASE_CONTROL (76)
#define JDKSAVDECC_DESCRIPTOR_JACK_LEN (78)

/*@}*/

/** \addtogroup descriptor_avb_interface AVB_INTERFACE Descriptor - Clause 7.2.8
 */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_MAC_ADDRESS (70)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_INTERFACE_FLAGS (76)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_IDENTITY (78)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PRIORITY1 (86)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_CLASS (87)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_OFFSET_SCALED_LOG_VARIANCE (88)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_ACCURACY (90)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PRIORITY2 (91)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DOMAIN_NUMBER (92)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_SYNC_INTERVAL (93)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_ANNOUNCE_INTERVAL (94)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_PDELAY_INTERVAL (95)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PORT_NUMBER (96)
#define JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_LEN (98)

/*@}*/

/** \addtogroup descriptor_clock_source CLOCK_SOURCE Descriptor - Clause 7.2.9
 */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_FLAGS (70)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_TYPE (72)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_IDENTIFIER (74)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_LOCATION_TYPE (82)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_LOCATION_INDEX (84)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_LEN (86)

/*@}*/

/** \addtogroup descriptor_memory_object MEMORY_OBJECT Descriptor - Clause
 * 7.2.10  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_MEMORY_OBJECT_TYPE (70)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_TARGET_DESCRIPTOR_TYPE (72)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_TARGET_DESCRIPTOR_INDEX (74)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_START_ADDRESS (76)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_MAXIMUM_LENGTH (84)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_LENGTH (92)
#define JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_LEN (100)

/*@}*/

/** \addtogroup descriptor_locale LOCALE Descriptor - Clause 7.2.11  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_LOCALE_IDENTIFIER (4)
#define JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_NUMBER_OF_STRINGS (68)
#define JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_BASE_STRINGS (70)
#define JDKSAVDECC_DESCRIPTOR_LOCALE_LEN (72)

/*@}*/

/** \addtogroup descriptor_strings STRINGS Descriptor - Clause 7.2.12  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_0 (4)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_1 (68)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_2 (132)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_3 (196)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_4 (260)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_5 (324)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_6 (388)
#define JDKSAVDECC_DESCRIPTOR_STRINGS_LEN (452)

/*@}*/

/** \addtogroup descriptor_stream_port STREAM_PORT_INPUT and STREAM_PORT_OUTPUT
 * Descriptor - Clause 7.2.13  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_CLOCK_DOMAIN_INDEX (4)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_PORT_FLAGS (6)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_CONTROLS (8)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_CONTROL (10)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_CLUSTERS (12)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_CLUSTER (14)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_MAPS (16)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_MAP (18)
#define JDKSAVDECC_DESCRIPTOR_STREAM_PORT_LEN (20)

/*@}*/

/** \addtogroup descriptor_external_port EXTERNAL_PORT_INPUT and EXTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.14  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_CLOCK_DOMAIN_INDEX (4)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_PORT_FLAGS (6)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_NUMBER_OF_CONTROLS (8)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_BASE_CONTROL (10)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_TYPE (12)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_INDEX (14)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_OUTPUT (16)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_BLOCK_LATENCY (18)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_JACK_INDEX (22)
#define JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_LEN (24)

/*@}*/

/** \addtogroup descriptor_internal_port INTERNAL_PORT_INPUT and INTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.15  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_CLOCK_DOMAIN_INDEX (4)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_PORT_FLAGS (6)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_NUMBER_OF_CONTROLS (8)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_BASE_CONTROL (10)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_TYPE (12)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_INDEX (14)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_OUTPUT (16)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_BLOCK_LATENCY (18)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_INTERNAL_INDEX (22)
#define JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_LEN (24)

/*@}*/

/** \addtogroup descriptor_audio_cluster AUDIO_CLUSTER Descriptor - Clause 7.2.16  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_TYPE (70)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_INDEX (72)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_OUTPUT (74)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_PATH_LATENCY (76)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_BLOCK_LATENCY (80)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_CHANNEL_COUNT (84)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_FORMAT (86)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_LEN (87)

/*@}*/

/** \addtogroup descriptor_video_cluster VIDEO_CLUSTER Descriptor - Clause 7.2.17  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_TYPE (70)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_INDEX (72)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_OUTPUT (74)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_PATH_LATENCY (76)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_BLOCK_LATENCY (80)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_FORMAT (84)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_FORMAT_SPECIFIC (85)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS_OFFSET (89)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS_COUNT (91)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_SAMPLING_RATE (93)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_OFFSET (97)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_COUNT (99)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_ASPECT_RATIO (101)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_ASPECT_RATIOS_OFFSET (103)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_ASPECT_RATIOS_COUNT (105)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_SIZE (107)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SIZES_OFFSET (111)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SIZES_COUNT (113)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_COLOR_SPACE (115)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_COLOR_SPACES_OFFSET (117)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_COLOR_SPACES_COUNT (119)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS (121)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_LEN (121)

/*@}*/

/** \addtogroup descriptor_sensor_cluster SENSOR_CLUSTER Descriptor - Clause 7.2.18  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_TYPE (70)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_INDEX (72)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_OUTPUT (74)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_PATH_LATENCY (76)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_BLOCK_LATENCY (80)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_CURRENT_FORMAT (84)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS_OFFSET (92)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS_COUNT (94)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_CURRENT_SAMPLING_RATE (96)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_OFFSET (100)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_COUNT (102)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS (104)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_LEN (104)

/*@}*/

/** \addtogroup descriptor_audio_map AUDIO_MAP Descriptor - Clause 7.2.19  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_MAPPINGS_OFFSET (4)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_NUMBER_OF_MAPPINGS (6)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_MAPPINGS (8)
#define JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_LEN (8)

/*@}*/

/** \addtogroup descriptor_video_map VIDEO_MAP Descriptor - Clause 7.2.20  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_MAPPINGS_OFFSET (4)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_NUMBER_OF_MAPPINGS (6)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_MAPPINGS (8)
#define JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_LEN (8)

/*@}*/

/** \addtogroup descriptor_sensor_map SENSOR_MAP Descriptor - Clause 7.2.21  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_MAPPINGS_OFFSET (4)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_NUMBER_OF_MAPPINGS (6)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_MAPPINGS (8)
#define JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_LEN (8)

/*@}*/

/** \addtogroup descriptor_control CONTROL Descriptor - Clause 7.2.22  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_VALUE_TYPE (80)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_TYPE (82)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_RESET_TIME (90)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_VALUES_OFFSET (94)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_NUMBER_OF_VALUES (96)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_TYPE (98)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_INDEX (100)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_OUTPUT (102)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_VALUE_DETAILS (104)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_LEN (104)

/// See IEEE Std 1722.1-2013 Clause 7.2.22 Table 7.38
#define JDKSAVDECC_DESCRIPTOR_CONTROL_VALUE_DETAILS_MAX_LENGTH (404)

/*@}*/

/** \addtogroup descriptor_signal_selector SIGNAL_SELECTOR Descriptor - Clause 7.2.23  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_SOURCES_OFFSET (80)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_NUMBER_OF_SOURCES (82)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_TYPE (84)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_INDEX (86)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_OUTPUT (88)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_TYPE (90)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_INDEX (92)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_OUTPUT (94)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_SOURCES (96)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_LEN (96)

/*@}*/

/** \addtogroup descriptor_mixer MIXER Descriptor - Clause 7.2.24  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_VALUE_TYPE (80)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_SOURCES_OFFSET (82)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_NUMBER_OF_SOURCES (84)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_VALUE_OFFSET (86)
#define JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_SOURCES (88)
#define JDKSAVDECC_DESCRIPTOR_MIXER_LEN (88)

/*@}*/

/** \addtogroup descriptor_matrix MATRIX Descriptor - Clause 7.2.25  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_VALUE_TYPE (80)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_TYPE (82)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_WIDTH (90)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_HEIGHT (92)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_VALUES_OFFSET (94)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_NUMBER_OF_VALUES (96)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_NUMBER_OF_SOURCES (98)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_BASE_SOURCE (100)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_VALUE_DETAILS (102)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_LEN (102)

/*@}*/

/** \addtogroup descriptor_matrix_signal Matrix Signal Descriptor - Clause 7.2.26  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS_COUNT (4)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS_OFFSET (6)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS (8)
#define JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_LEN (8)

/*@}*/

/** \addtogroup descriptor_signal_splitter SIGNAL_SPLITTER Descriptor - Clause 7.2.27  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_TYPE (80)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_INDEX (82)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_OUTPUT (84)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_NUMBER_OF_OUTPUTS (86)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP_COUNT (88)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP_OFFSET (90)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP (92)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_LEN (92)

/*@}*/

/** \addtogroup descriptor_signal_combiner SIGNAL_COMBINER Descriptor - Clause 7.2.28  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP_COUNT (80)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP_OFFSET (82)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_SOURCES_OFFSET (84)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_NUMBER_OF_SOURCES (86)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP (88)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_LEN (88)

/*@}*/

/** \addtogroup descriptor_signal_demultiplexer SIGNAL_DEMULTIPLEXER Descriptor - Clause 7.2.29  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_TYPE (80)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_INDEX (82)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_OUTPUT (84)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_NUMBER_OF_OUTPUTS (86)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP_COUNT (88)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP_OFFSET (90)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP (92)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_LEN (92)

/*@}*/

/** \addtogroup descriptor_signal_multiplexer SIGNAL_MULTIPLEXER Descriptor - Clause 7.2.30  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP_COUNT (80)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP_OFFSET (82)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_SOURCES_OFFSET (84)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_NUMBER_OF_SOURCES (86)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP (88)
#define JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_LEN (88)

/*@}*/

/** \addtogroup descriptor_transcoder SIGNAL_TRANSCODER Descriptor - Clause 7.2.31  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_BLOCK_LATENCY (70)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_LATENCY (74)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_DOMAIN (78)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_VALUE_TYPE (80)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_VALUES_OFFSET (82)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_NUMBER_OF_VALUES (84)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_TYPE (86)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_INDEX (88)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_OUTPUT (90)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_VALUE_DETAILS (92)
#define JDKSAVDECC_DESCRIPTOR_TRANSCODER_LEN (92)

/*@}*/

/** \addtogroup descriptor_clock_domain CLOCK_DOMAIN Descriptor - Clause 7.2.32
 */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCE_INDEX (70)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES_OFFSET (72)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES_COUNT (74)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES (76)
#define JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_LEN (76)

/*@}*/

/** \addtogroup descriptor_control_block CONTROL_BLOCK Descriptor - Clause 7.2.33  */
/*@{*/

#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_DESCRIPTOR_TYPE (0)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_DESCRIPTOR_INDEX (2)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_OBJECT_NAME (4)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_LOCALIZED_DESCRIPTION (68)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_NUMBER_OF_CONTROLS (70)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_BASE_CONTROL (72)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_FINAL_CONTROL_INDEX (74)
#define JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_LEN (76)

/*@}*/

/** \addtogroup values_type_max values_type_max : Maximum Counts for Value Types - Clause 7.2.22  */
/*@{*/

#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_INT8 (0x40)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT8 (0x40)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_INT16 (0x25)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT16 (0x25)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_INT32 (0x14)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT32 (0x14)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_INT64 (0x7)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT64 (0x7)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_FLOAT (0x14)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_LINEAR_DOUBLE (0x7)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT8 (0x400)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT8 (0x400)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT16 (0x199)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT16 (0x199)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT32 (0x98)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT32 (0x98)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT64 (0x48)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT64 (0x48)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_FLOAT (0x98)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_DOUBLE (0x48)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_UTF8 (0x1)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_BODE_PLOT (0x29)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_INT8 (0x396)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT8 (0x396)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_INT16 (0x196)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT16 (0x196)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_INT32 (0x96)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT32 (0x96)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_INT64 (0x46)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT64 (0x46)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_FLOAT (0x96)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_ARRAY_DOUBLE (0x46)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SELECTOR_STRING (0x199)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SMPTE_TIME (0x1)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_SAMPLE_RATE (0x1)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_GPTP_TIME (0x1)
#define JDKSAVDECC_VALUES_TYPE_MAX_CONTROL_VENDOR (0x1)

/*@}*/

/** \addtogroup values_type_matrix_max values_type_matrix_max : Maximum Counts for Value Types - Clause 7.2.25  */
/*@{*/

#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_INT8 (0x40)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_UINT8 (0x40)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_INT16 (0x25)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_UINT16 (0x25)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_INT32 (0x14)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_UINT32 (0x14)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_INT64 (0x7)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_UINT64 (0x7)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_FLOAT (0x14)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_LINEAR_DOUBLE (0x7)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_INT8 (0x400)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_UINT8 (0x400)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_INT16 (0x199)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_UINT16 (0x199)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_INT32 (0x98)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_UINT32 (0x98)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_INT64 (0x48)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_UINT64 (0x48)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_FLOAT (0x98)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_DOUBLE (0x48)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_UTF8 (0x1)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_BODE_PLOT (0x29)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_INT8 (0x396)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_UINT8 (0x396)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_INT16 (0x196)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_UINT16 (0x196)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_INT32 (0x96)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_UINT32 (0x96)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_INT64 (0x46)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_UINT64 (0x46)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_FLOAT (0x96)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_ARRAY_DOUBLE (0x46)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SELECTOR_STRING (0x199)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SMPTE_TIME (0x1)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_SAMPLE_RATE (0x1)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_GPTP_TIME (0x1)
#define JDKSAVDECC_VALUES_TYPE_MATRIX_MAX_CONTROL_VENDOR (0x1)

/*@}*/

/** \addtogroup transcoder_values_type_max Maximum Counts for Value Types of a SIGNAL_TRANSCODER - Clause 7.2.31  */
/*@{*/

#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_INT8 (0x41)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT8 (0x41)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_INT16 (0x26)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT16 (0x26)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_INT32 (0x14)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT32 (0x14)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_INT64 (0x8)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_UINT64 (0x8)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_FLOAT (0x14)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_LINEAR_DOUBLE (0x8)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT8 (0x412)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT8 (0x412)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT16 (0x205)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT16 (0x205)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT32 (0x101)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT32 (0x101)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_INT64 (0x49)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_UINT64 (0x49)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_FLOAT (0x101)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_DOUBLE (0x49)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_INT8 (0x408)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT8 (0x408)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_INT16 (0x202)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT16 (0x202)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_INT32 (0x99)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT32 (0x99)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_INT64 (0x47)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_UINT64 (0x47)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_FLOAT (0x99)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_ARRAY_DOUBLE (0x47)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SELECTOR_STRING (0x205)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_SAMPLE_RATE (0x1)
#define JDKSAVDECC_TRANSCODER_VALUES_TYPE_MAX_CONTROL_VENDOR (0x1)

/*@}*/

/** \addtogroup mixer_value_formats mixer_value_formats : Maximum Sources per Control Value Type - Clause 7.2.24  */
/*@{*/

#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_INT8 (0x68)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_UINT8 (0x68)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_INT16 (0x67)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_UINT16 (0x67)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_INT32 (0x65)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_UINT32 (0x65)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_INT64 (0x61)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_UINT64 (0x61)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_FLOAT (0x65)
#define JDKSAVDECC_MIXER_VALUE_FORMATS_CONTROL_LINEAR_DOUBLE (0x61)

/*@}*/

ssize_t
    jdksavdecc_aem_write_descriptor_counts(uint16_t descriptor_type, uint16_t count, void *buf, ssize_t pos, ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_int8(int8_t minimum_value,
                                                       int8_t maximum_value,
                                                       int8_t step_value,
                                                       int8_t default_value,
                                                       int8_t current_value,
                                                       uint8_t multiplier,
                                                       uint8_t unit_code,
                                                       uint16_t localized_string_reference,
                                                       void *buf,
                                                       ssize_t pos,
                                                       ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_uint8(uint8_t minimum_value,
                                                        uint8_t maximum_value,
                                                        uint8_t step_value,
                                                        uint8_t default_value,
                                                        uint8_t current_value,
                                                        uint8_t multiplier,
                                                        uint8_t unit_code,
                                                        uint16_t localized_string_reference,
                                                        void *buf,
                                                        ssize_t pos,
                                                        ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_int16(int16_t minimum_value,
                                                        int16_t maximum_value,
                                                        int16_t step_value,
                                                        int16_t default_value,
                                                        int16_t current_value,
                                                        uint8_t multiplier,
                                                        uint8_t unit_code,
                                                        uint16_t localized_string_reference,
                                                        void *buf,
                                                        ssize_t pos,
                                                        ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_uint16(uint16_t minimum_value,
                                                         uint16_t maximum_value,
                                                         uint16_t step_value,
                                                         uint16_t default_value,
                                                         uint16_t current_value,
                                                         uint8_t multiplier,
                                                         uint8_t unit_code,
                                                         uint16_t localized_string_reference,
                                                         void *buf,
                                                         ssize_t pos,
                                                         ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_int32(int32_t minimum_value,
                                                        int32_t maximum_value,
                                                        int32_t step_value,
                                                        int32_t default_value,
                                                        int32_t current_value,
                                                        uint8_t multiplier,
                                                        uint8_t unit_code,
                                                        uint16_t localized_string_reference,
                                                        void *buf,
                                                        ssize_t pos,
                                                        ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_uint32(uint32_t minimum_value,
                                                         uint32_t maximum_value,
                                                         uint32_t step_value,
                                                         uint32_t default_value,
                                                         uint32_t current_value,
                                                         uint8_t multiplier,
                                                         uint8_t unit_code,
                                                         uint16_t localized_string_reference,
                                                         void *buf,
                                                         ssize_t pos,
                                                         ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_int64(int64_t minimum_value,
                                                        int64_t maximum_value,
                                                        int64_t step_value,
                                                        int64_t default_value,
                                                        int64_t current_value,
                                                        uint8_t multiplier,
                                                        uint8_t unit_code,
                                                        uint16_t localized_string_reference,
                                                        void *buf,
                                                        ssize_t pos,
                                                        ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_uint64(uint64_t minimum_value,
                                                         uint64_t maximum_value,
                                                         uint64_t step_value,
                                                         uint64_t default_value,
                                                         uint64_t current_value,
                                                         uint8_t multiplier,
                                                         uint8_t unit_code,
                                                         uint16_t localized_string_reference,
                                                         void *buf,
                                                         ssize_t pos,
                                                         ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_float(float minimum_value,
                                                        float maximum_value,
                                                        float step_value,
                                                        float default_value,
                                                        float current_value,
                                                        uint8_t multiplier,
                                                        uint8_t unit_code,
                                                        uint16_t localized_string_reference,
                                                        void *buf,
                                                        ssize_t pos,
                                                        ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_linear_double(double minimum_value,
                                                         double maximum_value,
                                                         double step_value,
                                                         double default_value,
                                                         double current_value,
                                                         uint8_t multiplier,
                                                         uint8_t unit_code,
                                                         uint16_t localized_string_reference,
                                                         void *buf,
                                                         ssize_t pos,
                                                         ssize_t buf_len);

/** @todo Selector types, array types, utf, bode plot, smpte time, sample rate,
 * gptp time */
struct jdksavdecc_aem_additional_control_type;

ssize_t jdksavdecc_aem_write_values_format_utf8(struct jdksavdecc_string *s, void *buf, ssize_t pos, ssize_t buf_len);

ssize_t jdksavdecc_aem_write_values_format_array_uint16(uint16_t minimum_value,
                                                        uint16_t maximum_value,
                                                        uint16_t step_value,
                                                        uint16_t default_value,
                                                        uint8_t multiplier,
                                                        uint8_t unit_code,
                                                        uint16_t localized_string_reference,
                                                        uint16_t *current_values,
                                                        int16_t num_values,
                                                        void *buf,
                                                        ssize_t pos,
                                                        ssize_t buf_len);

/** \addtogroup audio_mapping Audio Mappings Format - Clause 7.2.19.1  */
/*@{*/

/**
 * Extract the uint16 value of the mapping_stream_index field of the
 *AUDIO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_stream_index value
 */
static inline uint16_t jdksavdecc_audio_mapping_get_mapping_stream_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Store a uint16 value to the mapping_stream_index field of the AUDIO_MAPPING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_stream_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mapping_set_mapping_stream_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Extract the uint16 value of the mapping_stream_channel field of the
 *AUDIO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_stream_channel value
 */
static inline uint16_t jdksavdecc_audio_mapping_get_mapping_stream_channel(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_STREAM_CHANNEL);
}

/**
 * Store a uint16 value to the mapping_stream_channel field of the AUDIO_MAPPING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_stream_channel value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mapping_set_mapping_stream_channel(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_STREAM_CHANNEL);
}

/**
 * Extract the uint16 value of the mapping_cluster_offset field of the
 *AUDIO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_cluster_offset value
 */
static inline uint16_t jdksavdecc_audio_mapping_get_mapping_cluster_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/**
 * Store a uint16 value to the mapping_cluster_offset field of the AUDIO_MAPPING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_cluster_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mapping_set_mapping_cluster_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/**
 * Extract the uint16 value of the mapping_cluster_channel field of the
 *AUDIO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_cluster_channel value
 */
static inline uint16_t jdksavdecc_audio_mapping_get_mapping_cluster_channel(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_CLUSTER_CHANNEL);
}

/**
 * Store a uint16 value to the mapping_cluster_channel field of the
 *AUDIO_MAPPING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_cluster_channel value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mapping_set_mapping_cluster_channel(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPING_OFFSET_MAPPING_CLUSTER_CHANNEL);
}

/*@}*/

/** \addtogroup audio_mapping Audio Mappings Format - Clause 7.2.19.1  */
/*@{*/

/// Audio Mappings Format - Clause 7.2.19.1
struct jdksavdecc_audio_mapping {
    uint16_t mapping_stream_index;
    uint16_t mapping_stream_channel;
    uint16_t mapping_cluster_offset;
    uint16_t mapping_cluster_channel;
};

/**
 * Extract the jdksavdecc_audio_mapping_t structure from a network buffer.
 *
 *  - Clause 7.2.19.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to audio_mapping structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_audio_mapping_read(struct jdksavdecc_audio_mapping *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AUDIO_MAPPING_LEN);
    if (r >= 0) {
        p->mapping_stream_index = jdksavdecc_audio_mapping_get_mapping_stream_index(base, pos);
        p->mapping_stream_channel = jdksavdecc_audio_mapping_get_mapping_stream_channel(base, pos);
        p->mapping_cluster_offset = jdksavdecc_audio_mapping_get_mapping_cluster_offset(base, pos);
        p->mapping_cluster_channel = jdksavdecc_audio_mapping_get_mapping_cluster_channel(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_audio_mapping_t structure to a network buffer.
 *
 *  - Clause 7.2.19.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to audio_mapping structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_audio_mapping_write(struct jdksavdecc_audio_mapping const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AUDIO_MAPPING_LEN);
    if (r >= 0) {
        jdksavdecc_audio_mapping_set_mapping_stream_index(p->mapping_stream_index, base, pos);
        jdksavdecc_audio_mapping_set_mapping_stream_channel(p->mapping_stream_channel, base, pos);
        jdksavdecc_audio_mapping_set_mapping_cluster_offset(p->mapping_cluster_offset, base, pos);
        jdksavdecc_audio_mapping_set_mapping_cluster_channel(p->mapping_cluster_channel, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup video_mapping Video Mappings Format - Clause 7.2.20.1  */
/*@{*/

/**
 * Extract the uint16 value of the mapping_stream_index field of the
 *VIDEO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_stream_index value
 */
static inline uint16_t jdksavdecc_video_mapping_get_mapping_stream_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Store a uint16 value to the mapping_stream_index field of the VIDEO_MAPPING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_stream_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mapping_set_mapping_stream_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Extract the uint16 value of the mapping_program_stream field of the
 *VIDEO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_program_stream value
 */
static inline uint16_t jdksavdecc_video_mapping_get_mapping_program_stream(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_PROGRAM_STREAM);
}

/**
 * Store a uint16 value to the mapping_program_stream field of the VIDEO_MAPPING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_program_stream value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mapping_set_mapping_program_stream(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_PROGRAM_STREAM);
}

/**
 * Extract the uint16 value of the mapping_elementary_stream field of the
 *VIDEO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_elementary_stream value
 */
static inline uint16_t jdksavdecc_video_mapping_get_mapping_elementary_stream(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_ELEMENTARY_STREAM);
}

/**
 * Store a uint16 value to the mapping_elementary_stream field of the
 *VIDEO_MAPPING object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_elementary_stream value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mapping_set_mapping_elementary_stream(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_ELEMENTARY_STREAM);
}

/**
 * Extract the uint16 value of the mapping_cluster_offset field of the
 *VIDEO_MAPPING object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_cluster_offset value
 */
static inline uint16_t jdksavdecc_video_mapping_get_mapping_cluster_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/**
 * Store a uint16 value to the mapping_cluster_offset field of the VIDEO_MAPPING
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_cluster_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mapping_set_mapping_cluster_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPING_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/*@}*/

/** \addtogroup video_mapping Video Mappings Format - Clause 7.2.20.1  */
/*@{*/

/// Video Mappings Format - Clause 7.2.20.1
struct jdksavdecc_video_mapping {
    uint16_t mapping_stream_index;
    uint16_t mapping_program_stream;
    uint16_t mapping_elementary_stream;
    uint16_t mapping_cluster_offset;
};

/**
 * Extract the jdksavdecc_video_mapping_t structure from a network buffer.
 *
 *  - Clause 7.2.20.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to video_mapping structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_video_mapping_read(struct jdksavdecc_video_mapping *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VIDEO_MAPPING_LEN);
    if (r >= 0) {
        p->mapping_stream_index = jdksavdecc_video_mapping_get_mapping_stream_index(base, pos);
        p->mapping_program_stream = jdksavdecc_video_mapping_get_mapping_program_stream(base, pos);
        p->mapping_elementary_stream = jdksavdecc_video_mapping_get_mapping_elementary_stream(base, pos);
        p->mapping_cluster_offset = jdksavdecc_video_mapping_get_mapping_cluster_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_video_mapping_t structure to a network buffer.
 *
 *  - Clause 7.2.20.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to video_mapping structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_video_mapping_write(struct jdksavdecc_video_mapping const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VIDEO_MAPPING_LEN);
    if (r >= 0) {
        jdksavdecc_video_mapping_set_mapping_stream_index(p->mapping_stream_index, base, pos);
        jdksavdecc_video_mapping_set_mapping_program_stream(p->mapping_program_stream, base, pos);
        jdksavdecc_video_mapping_set_mapping_elementary_stream(p->mapping_elementary_stream, base, pos);
        jdksavdecc_video_mapping_set_mapping_cluster_offset(p->mapping_cluster_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup signal_selector_source Signal Selector Sources Field - Clause
 * 7.2.23.1  */
/*@{*/

/**
 * Extract the uint16 value of the signal_type field of the
 *SIGNAL_SELECTOR_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_signal_selector_source_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the SIGNAL_SELECTOR_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_signal_selector_source_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *SIGNAL_SELECTOR_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_signal_selector_source_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the SIGNAL_SELECTOR_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_signal_selector_source_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *SIGNAL_SELECTOR_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_signal_selector_source_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the SIGNAL_SELECTOR_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_signal_selector_source_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_OFFSET_SIGNAL_OUTPUT);
}

/*@}*/

/** \addtogroup signal_selector_source Signal Selector Sources Field - Clause
 * 7.2.23.1  */
/*@{*/

/// Signal Selector Sources Field - Clause 7.2.23.1
struct jdksavdecc_signal_selector_source {
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
};

/**
 * Extract the jdksavdecc_signal_selector_source_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.23.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to signal_selector_source structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_signal_selector_source_read(struct jdksavdecc_signal_selector_source *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_LEN);
    if (r >= 0) {
        p->signal_type = jdksavdecc_signal_selector_source_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_signal_selector_source_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_signal_selector_source_get_signal_output(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_signal_selector_source_t structure to a network buffer.
 *
 *  - Clause 7.2.23.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to signal_selector_source structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_signal_selector_source_write(struct jdksavdecc_signal_selector_source const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_SIGNAL_SELECTOR_SOURCE_LEN);
    if (r >= 0) {
        jdksavdecc_signal_selector_source_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_signal_selector_source_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_signal_selector_source_set_signal_output(p->signal_output, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup mixer_source Mixer Sources Field - Clause 7.2.24.1  */
/*@{*/

/**
 * Extract the uint16 value of the signal_type field of the MIXER_SOURCE object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_mixer_source_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the MIXER_SOURCE object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_mixer_source_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the MIXER_SOURCE object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_mixer_source_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the MIXER_SOURCE object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_mixer_source_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the MIXER_SOURCE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_mixer_source_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the MIXER_SOURCE object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_mixer_source_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MIXER_SOURCE_OFFSET_SIGNAL_OUTPUT);
}

/*@}*/

/** \addtogroup mixer_source Mixer Sources Field - Clause 7.2.24.1  */
/*@{*/

/// Mixer Sources Field - Clause 7.2.24.1
struct jdksavdecc_mixer_source {
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
};

/**
 * Extract the jdksavdecc_mixer_source_t structure from a network buffer.
 *
 *  - Clause 7.2.24.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to mixer_source structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_mixer_source_read(struct jdksavdecc_mixer_source *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_MIXER_SOURCE_LEN);
    if (r >= 0) {
        p->signal_type = jdksavdecc_mixer_source_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_mixer_source_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_mixer_source_get_signal_output(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_mixer_source_t structure to a network buffer.
 *
 *  - Clause 7.2.24.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to mixer_source structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_mixer_source_write(struct jdksavdecc_mixer_source const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_MIXER_SOURCE_LEN);
    if (r >= 0) {
        jdksavdecc_mixer_source_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_mixer_source_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_mixer_source_set_signal_output(p->signal_output, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup splitter_map splitter_map Format - Clause 7.2.27.1  */
/*@{*/

/**
 * Extract the uint16 value of the sub_signal_start field of the SPLITTER_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sub_signal_start value
 */
static inline uint16_t jdksavdecc_splitter_map_get_sub_signal_start(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_SPLITTER_MAP_OFFSET_SUB_SIGNAL_START);
}

/**
 * Store a uint16 value to the sub_signal_start field of the SPLITTER_MAP object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sub_signal_start value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_splitter_map_set_sub_signal_start(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_SPLITTER_MAP_OFFSET_SUB_SIGNAL_START);
}

/**
 * Extract the uint16 value of the sub_signal_count field of the SPLITTER_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sub_signal_count value
 */
static inline uint16_t jdksavdecc_splitter_map_get_sub_signal_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_SPLITTER_MAP_OFFSET_SUB_SIGNAL_COUNT);
}

/**
 * Store a uint16 value to the sub_signal_count field of the SPLITTER_MAP object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sub_signal_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_splitter_map_set_sub_signal_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_SPLITTER_MAP_OFFSET_SUB_SIGNAL_COUNT);
}

/**
 * Extract the uint16 value of the output_index field of the SPLITTER_MAP object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t output_index value
 */
static inline uint16_t jdksavdecc_splitter_map_get_output_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_SPLITTER_MAP_OFFSET_OUTPUT_INDEX);
}

/**
 * Store a uint16 value to the output_index field of the SPLITTER_MAP object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t output_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_splitter_map_set_output_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_SPLITTER_MAP_OFFSET_OUTPUT_INDEX);
}

/*@}*/

/** \addtogroup splitter_map splitter_map Format - Clause 7.2.27.1  */
/*@{*/

/// splitter_map Format - Clause 7.2.27.1
struct jdksavdecc_splitter_map {
    uint16_t sub_signal_start;
    uint16_t sub_signal_count;
    uint16_t output_index;
};

/**
 * Extract the jdksavdecc_splitter_map_t structure from a network buffer.
 *
 *  - Clause 7.2.27.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to splitter_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_splitter_map_read(struct jdksavdecc_splitter_map *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_SPLITTER_MAP_LEN);
    if (r >= 0) {
        p->sub_signal_start = jdksavdecc_splitter_map_get_sub_signal_start(base, pos);
        p->sub_signal_count = jdksavdecc_splitter_map_get_sub_signal_count(base, pos);
        p->output_index = jdksavdecc_splitter_map_get_output_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_splitter_map_t structure to a network buffer.
 *
 *  - Clause 7.2.27.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to splitter_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_splitter_map_write(struct jdksavdecc_splitter_map const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_SPLITTER_MAP_LEN);
    if (r >= 0) {
        jdksavdecc_splitter_map_set_sub_signal_start(p->sub_signal_start, base, pos);
        jdksavdecc_splitter_map_set_sub_signal_count(p->sub_signal_count, base, pos);
        jdksavdecc_splitter_map_set_output_index(p->output_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup combiner_map combiner_map Format - Clause 7.2.28.1  */
/*@{*/

/**
 * Extract the uint16 value of the sub_signal_start field of the COMBINER_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sub_signal_start value
 */
static inline uint16_t jdksavdecc_combiner_map_get_sub_signal_start(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_COMBINER_MAP_OFFSET_SUB_SIGNAL_START);
}

/**
 * Store a uint16 value to the sub_signal_start field of the COMBINER_MAP object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sub_signal_start value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_combiner_map_set_sub_signal_start(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_COMBINER_MAP_OFFSET_SUB_SIGNAL_START);
}

/**
 * Extract the uint16 value of the sub_signal_count field of the COMBINER_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sub_signal_count value
 */
static inline uint16_t jdksavdecc_combiner_map_get_sub_signal_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_COMBINER_MAP_OFFSET_SUB_SIGNAL_COUNT);
}

/**
 * Store a uint16 value to the sub_signal_count field of the COMBINER_MAP object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sub_signal_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_combiner_map_set_sub_signal_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_COMBINER_MAP_OFFSET_SUB_SIGNAL_COUNT);
}

/**
 * Extract the uint16 value of the input_index field of the COMBINER_MAP object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t input_index value
 */
static inline uint16_t jdksavdecc_combiner_map_get_input_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_COMBINER_MAP_OFFSET_INPUT_INDEX);
}

/**
 * Store a uint16 value to the input_index field of the COMBINER_MAP object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t input_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_combiner_map_set_input_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_COMBINER_MAP_OFFSET_INPUT_INDEX);
}

/*@}*/

/** \addtogroup combiner_map combiner_map Format - Clause 7.2.28.1  */
/*@{*/

/// combiner_map Format - Clause 7.2.28.1
struct jdksavdecc_combiner_map {
    uint16_t sub_signal_start;
    uint16_t sub_signal_count;
    uint16_t input_index;
};

/**
 * Extract the jdksavdecc_combiner_map_t structure from a network buffer.
 *
 *  - Clause 7.2.28.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to combiner_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_combiner_map_read(struct jdksavdecc_combiner_map *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_COMBINER_MAP_LEN);
    if (r >= 0) {
        p->sub_signal_start = jdksavdecc_combiner_map_get_sub_signal_start(base, pos);
        p->sub_signal_count = jdksavdecc_combiner_map_get_sub_signal_count(base, pos);
        p->input_index = jdksavdecc_combiner_map_get_input_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_combiner_map_t structure to a network buffer.
 *
 *  - Clause 7.2.28.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to combiner_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_combiner_map_write(struct jdksavdecc_combiner_map const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_COMBINER_MAP_LEN);
    if (r >= 0) {
        jdksavdecc_combiner_map_set_sub_signal_start(p->sub_signal_start, base, pos);
        jdksavdecc_combiner_map_set_sub_signal_count(p->sub_signal_count, base, pos);
        jdksavdecc_combiner_map_set_input_index(p->input_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup demultiplexer_map demultiplexer_map Format - Clause 7.2.29.1  */
/*@{*/

/**
 * Extract the uint16 value of the sub_signal_start field of the
 *DEMULTIPLEXER_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sub_signal_start value
 */
static inline uint16_t jdksavdecc_demultiplexer_map_get_sub_signal_start(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_SUB_SIGNAL_START);
}

/**
 * Store a uint16 value to the sub_signal_start field of the DEMULTIPLEXER_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sub_signal_start value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_demultiplexer_map_set_sub_signal_start(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_SUB_SIGNAL_START);
}

/**
 * Extract the uint16 value of the sub_signal_count field of the
 *DEMULTIPLEXER_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sub_signal_count value
 */
static inline uint16_t jdksavdecc_demultiplexer_map_get_sub_signal_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_SUB_SIGNAL_COUNT);
}

/**
 * Store a uint16 value to the sub_signal_count field of the DEMULTIPLEXER_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sub_signal_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_demultiplexer_map_set_sub_signal_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_SUB_SIGNAL_COUNT);
}

/**
 * Extract the uint16 value of the output_index field of the DEMULTIPLEXER_MAP
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t output_index value
 */
static inline uint16_t jdksavdecc_demultiplexer_map_get_output_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_OUTPUT_INDEX);
}

/**
 * Store a uint16 value to the output_index field of the DEMULTIPLEXER_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t output_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_demultiplexer_map_set_output_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DEMULTIPLEXER_MAP_OFFSET_OUTPUT_INDEX);
}

/*@}*/

/** \addtogroup demultiplexer_map demultiplexer_map Format - Clause 7.2.29.1  */
/*@{*/

/// demultiplexer_map Format - Clause 7.2.29.1
struct jdksavdecc_demultiplexer_map {
    uint16_t sub_signal_start;
    uint16_t sub_signal_count;
    uint16_t output_index;
};

/**
 * Extract the jdksavdecc_demultiplexer_map_t structure from a network buffer.
 *
 *  - Clause 7.2.29.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to demultiplexer_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_demultiplexer_map_read(struct jdksavdecc_demultiplexer_map *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DEMULTIPLEXER_MAP_LEN);
    if (r >= 0) {
        p->sub_signal_start = jdksavdecc_demultiplexer_map_get_sub_signal_start(base, pos);
        p->sub_signal_count = jdksavdecc_demultiplexer_map_get_sub_signal_count(base, pos);
        p->output_index = jdksavdecc_demultiplexer_map_get_output_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_demultiplexer_map_t structure to a network buffer.
 *
 *  - Clause 7.2.29.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to demultiplexer_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_demultiplexer_map_write(struct jdksavdecc_demultiplexer_map const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DEMULTIPLEXER_MAP_LEN);
    if (r >= 0) {
        jdksavdecc_demultiplexer_map_set_sub_signal_start(p->sub_signal_start, base, pos);
        jdksavdecc_demultiplexer_map_set_sub_signal_count(p->sub_signal_count, base, pos);
        jdksavdecc_demultiplexer_map_set_output_index(p->output_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup multiplexer_source Signal Multiplexer Sources Field - Clause
 * 7.2.30.2  */
/*@{*/

/**
 * Extract the uint16 value of the signal_type field of the MULTIPLEXER_SOURCE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_multiplexer_source_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the MULTIPLEXER_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_multiplexer_source_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the MULTIPLEXER_SOURCE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_multiplexer_source_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the MULTIPLEXER_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_multiplexer_source_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the MULTIPLEXER_SOURCE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_multiplexer_source_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the MULTIPLEXER_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_multiplexer_source_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MULTIPLEXER_SOURCE_OFFSET_SIGNAL_OUTPUT);
}

/*@}*/

/** \addtogroup multiplexer_source Signal Multiplexer Sources Field - Clause
 * 7.2.30.2  */
/*@{*/

/// Signal Multiplexer Sources Field - Clause 7.2.30.2
struct jdksavdecc_multiplexer_source {
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
};

/**
 * Extract the jdksavdecc_multiplexer_source_t structure from a network buffer.
 *
 *  - Clause 7.2.30.2
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to multiplexer_source structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_multiplexer_source_read(struct jdksavdecc_multiplexer_source *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_MULTIPLEXER_SOURCE_LEN);
    if (r >= 0) {
        p->signal_type = jdksavdecc_multiplexer_source_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_multiplexer_source_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_multiplexer_source_get_signal_output(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_multiplexer_source_t structure to a network buffer.
 *
 *  - Clause 7.2.30.2
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to multiplexer_source structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_multiplexer_source_write(struct jdksavdecc_multiplexer_source const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_MULTIPLEXER_SOURCE_LEN);
    if (r >= 0) {
        jdksavdecc_multiplexer_source_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_multiplexer_source_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_multiplexer_source_set_signal_output(p->signal_output, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup values_bode_plot Bode Plot Value Details - Clause 7.3.5.2.5  */
/*@{*/

/**
 * Extract the uint32 value of the frequency_minimum field of the
 *VALUES_BODE_PLOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frequency_minimum value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_frequency_minimum(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_MINIMUM);
}

/**
 * Store a uint32 value to the frequency_minimum field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frequency_minimum value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_frequency_minimum(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_MINIMUM);
}

/**
 * Extract the uint32 value of the frequency_maximum field of the
 *VALUES_BODE_PLOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frequency_maximum value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_frequency_maximum(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_MAXIMUM);
}

/**
 * Store a uint32 value to the frequency_maximum field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frequency_maximum value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_frequency_maximum(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_MAXIMUM);
}

/**
 * Extract the uint32 value of the frequency_step field of the VALUES_BODE_PLOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frequency_step value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_frequency_step(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_STEP);
}

/**
 * Store a uint32 value to the frequency_step field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frequency_step value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_frequency_step(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_STEP);
}

/**
 * Extract the uint32 value of the frequency_default field of the
 *VALUES_BODE_PLOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t frequency_default value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_frequency_default(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_DEFAULT);
}

/**
 * Store a uint32 value to the frequency_default field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t frequency_default value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_frequency_default(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_FREQUENCY_DEFAULT);
}

/**
 * Extract the uint32 value of the magnitude_minimum field of the
 *VALUES_BODE_PLOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t magnitude_minimum value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_magnitude_minimum(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_MINIMUM);
}

/**
 * Store a uint32 value to the magnitude_minimum field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t magnitude_minimum value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_magnitude_minimum(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_MINIMUM);
}

/**
 * Extract the uint32 value of the magnitude_maximum field of the
 *VALUES_BODE_PLOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t magnitude_maximum value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_magnitude_maximum(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_MAXIMUM);
}

/**
 * Store a uint32 value to the magnitude_maximum field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t magnitude_maximum value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_magnitude_maximum(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_MAXIMUM);
}

/**
 * Extract the uint32 value of the magnitude_step field of the VALUES_BODE_PLOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t magnitude_step value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_magnitude_step(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_STEP);
}

/**
 * Store a uint32 value to the magnitude_step field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t magnitude_step value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_magnitude_step(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_STEP);
}

/**
 * Extract the uint32 value of the magnitude_default field of the
 *VALUES_BODE_PLOT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t magnitude_default value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_magnitude_default(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_DEFAULT);
}

/**
 * Store a uint32 value to the magnitude_default field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t magnitude_default value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_magnitude_default(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_MAGNITUDE_DEFAULT);
}

/**
 * Extract the uint32 value of the phase_minimum field of the VALUES_BODE_PLOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t phase_minimum value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_phase_minimum(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_MINIMUM);
}

/**
 * Store a uint32 value to the phase_minimum field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t phase_minimum value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_phase_minimum(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_MINIMUM);
}

/**
 * Extract the uint32 value of the phase_maximum field of the VALUES_BODE_PLOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t phase_maximum value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_phase_maximum(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_MAXIMUM);
}

/**
 * Store a uint32 value to the phase_maximum field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t phase_maximum value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_phase_maximum(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_MAXIMUM);
}

/**
 * Extract the uint32 value of the phase_step field of the VALUES_BODE_PLOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t phase_step value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_phase_step(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_STEP);
}

/**
 * Store a uint32 value to the phase_step field of the VALUES_BODE_PLOT object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t phase_step value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_phase_step(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_STEP);
}

/**
 * Extract the uint32 value of the phase_default field of the VALUES_BODE_PLOT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t phase_default value
 */
static inline uint32_t jdksavdecc_values_bode_plot_get_phase_default(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_DEFAULT);
}

/**
 * Store a uint32 value to the phase_default field of the VALUES_BODE_PLOT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t phase_default value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_bode_plot_set_phase_default(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_BODE_PLOT_OFFSET_PHASE_DEFAULT);
}

/*@}*/

/** \addtogroup values_bode_plot Bode Plot Value Details - Clause 7.3.5.2.5  */
/*@{*/

/// Bode Plot Value Details - Clause 7.3.5.2.5
struct jdksavdecc_values_bode_plot {
    uint32_t frequency_minimum;
    uint32_t frequency_maximum;
    uint32_t frequency_step;
    uint32_t frequency_default;
    uint32_t magnitude_minimum;
    uint32_t magnitude_maximum;
    uint32_t magnitude_step;
    uint32_t magnitude_default;
    uint32_t phase_minimum;
    uint32_t phase_maximum;
    uint32_t phase_step;
    uint32_t phase_default;
};

/**
 * Extract the jdksavdecc_values_bode_plot structure from a network buffer.
 *
 *  - Clause 7.3.5.2.5
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to values_bode_plot structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_bode_plot_read(struct jdksavdecc_values_bode_plot *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_BODE_PLOT_LEN);
    if (r >= 0) {
        p->frequency_minimum = jdksavdecc_values_bode_plot_get_frequency_minimum(base, pos);
        p->frequency_maximum = jdksavdecc_values_bode_plot_get_frequency_maximum(base, pos);
        p->frequency_step = jdksavdecc_values_bode_plot_get_frequency_step(base, pos);
        p->frequency_default = jdksavdecc_values_bode_plot_get_frequency_default(base, pos);
        p->magnitude_minimum = jdksavdecc_values_bode_plot_get_magnitude_minimum(base, pos);
        p->magnitude_maximum = jdksavdecc_values_bode_plot_get_magnitude_maximum(base, pos);
        p->magnitude_step = jdksavdecc_values_bode_plot_get_magnitude_step(base, pos);
        p->magnitude_default = jdksavdecc_values_bode_plot_get_magnitude_default(base, pos);
        p->phase_minimum = jdksavdecc_values_bode_plot_get_phase_minimum(base, pos);
        p->phase_maximum = jdksavdecc_values_bode_plot_get_phase_maximum(base, pos);
        p->phase_step = jdksavdecc_values_bode_plot_get_phase_step(base, pos);
        p->phase_default = jdksavdecc_values_bode_plot_get_phase_default(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_values_bode_plot structure to a network buffer.
 *
 *  - Clause 7.3.5.2.5
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to values_bode_plot structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_bode_plot_write(struct jdksavdecc_values_bode_plot const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_BODE_PLOT_LEN);
    if (r >= 0) {
        jdksavdecc_values_bode_plot_set_frequency_minimum(p->frequency_minimum, base, pos);
        jdksavdecc_values_bode_plot_set_frequency_maximum(p->frequency_maximum, base, pos);
        jdksavdecc_values_bode_plot_set_frequency_step(p->frequency_step, base, pos);
        jdksavdecc_values_bode_plot_set_frequency_default(p->frequency_default, base, pos);
        jdksavdecc_values_bode_plot_set_magnitude_minimum(p->magnitude_minimum, base, pos);
        jdksavdecc_values_bode_plot_set_magnitude_maximum(p->magnitude_maximum, base, pos);
        jdksavdecc_values_bode_plot_set_magnitude_step(p->magnitude_step, base, pos);
        jdksavdecc_values_bode_plot_set_magnitude_default(p->magnitude_default, base, pos);
        jdksavdecc_values_bode_plot_set_phase_minimum(p->phase_minimum, base, pos);
        jdksavdecc_values_bode_plot_set_phase_maximum(p->phase_maximum, base, pos);
        jdksavdecc_values_bode_plot_set_phase_step(p->phase_step, base, pos);
        jdksavdecc_values_bode_plot_set_phase_default(p->phase_default, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup values_smpte_time SMPTE Value Details - Clause 7.3.5.2.6  */
/*@{*/

/**
 * Extract the uint16 value of the hours field of the VALUES_SMPTE_TIME object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t hours value
 */
static inline uint16_t jdksavdecc_values_smpte_time_get_hours(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_HOURS);
}

/**
 * Store a uint16 value to the hours field of the VALUES_SMPTE_TIME object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t hours value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_hours(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_HOURS);
}

/**
 * Extract the uint8 value of the minutes field of the VALUES_SMPTE_TIME object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t minutes value
 */
static inline uint8_t jdksavdecc_values_smpte_time_get_minutes(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_MINUTES);
}

/**
 * Store a uint8 value to the minutes field of the VALUES_SMPTE_TIME object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t minutes value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_minutes(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_MINUTES);
}

/**
 * Extract the uint8 value of the seconds field of the VALUES_SMPTE_TIME object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t seconds value
 */
static inline uint8_t jdksavdecc_values_smpte_time_get_seconds(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_SECONDS);
}

/**
 * Store a uint8 value to the seconds field of the VALUES_SMPTE_TIME object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t seconds value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_seconds(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_SECONDS);
}

/**
 * Extract the uint8 value of the frames field of the VALUES_SMPTE_TIME object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t frames value
 */
static inline uint8_t jdksavdecc_values_smpte_time_get_frames(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_FRAMES);
}

/**
 * Store a uint8 value to the frames field of the VALUES_SMPTE_TIME object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t frames value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_frames(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_FRAMES);
}

/**
 * Extract the uint16 value of the subframes field of the VALUES_SMPTE_TIME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t subframes value
 */
static inline uint16_t jdksavdecc_values_smpte_time_get_subframes(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_SUBFRAMES);
}

/**
 * Store a uint16 value to the subframes field of the VALUES_SMPTE_TIME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t subframes value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_subframes(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_SUBFRAMES);
}

/**
 * Extract the uint8 value of the frames_per_second field of the
 *VALUES_SMPTE_TIME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t frames_per_second value
 */
static inline uint8_t jdksavdecc_values_smpte_time_get_frames_per_second(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_FRAMES_PER_SECOND);
}

/**
 * Store a uint8 value to the frames_per_second field of the VALUES_SMPTE_TIME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t frames_per_second value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_frames_per_second(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_FRAMES_PER_SECOND);
}

/**
 * Extract the uint8 value of the drop_frame field of the VALUES_SMPTE_TIME
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t drop_frame value
 */
static inline uint8_t jdksavdecc_values_smpte_time_get_drop_frame(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_DROP_FRAME);
}

/**
 * Store a uint8 value to the drop_frame field of the VALUES_SMPTE_TIME object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t drop_frame value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_drop_frame(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_DROP_FRAME);
}

/**
 * Extract the uint8 value of the pull field of the VALUES_SMPTE_TIME object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t pull value
 */
static inline uint8_t jdksavdecc_values_smpte_time_get_pull(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_PULL);
}

/**
 * Store a uint8 value to the pull field of the VALUES_SMPTE_TIME object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t pull value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_smpte_time_set_pull(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_VALUES_SMPTE_TIME_OFFSET_PULL);
}

/*@}*/

/** \addtogroup values_smpte_time SMPTE Value Details - Clause 7.3.5.2.6  */
/*@{*/

/// SMPTE Value Details - Clause 7.3.5.2.6
struct jdksavdecc_values_smpte_time {
    uint16_t hours;
    uint8_t minutes;
    uint8_t seconds;
    uint8_t frames;
    uint16_t subframes;
    uint8_t frames_per_second;
    uint8_t drop_frame;
    uint8_t pull;
};

/**
 * Extract the jdksavdecc_values_smpte_time structure from a network buffer.
 *
 *  - Clause 7.3.5.2.6
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to values_smpte_time structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_smpte_time_read(struct jdksavdecc_values_smpte_time *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_SMPTE_TIME_LEN);
    if (r >= 0) {
        p->hours = jdksavdecc_values_smpte_time_get_hours(base, pos);
        p->minutes = jdksavdecc_values_smpte_time_get_minutes(base, pos);
        p->seconds = jdksavdecc_values_smpte_time_get_seconds(base, pos);
        p->frames = jdksavdecc_values_smpte_time_get_frames(base, pos);
        p->subframes = jdksavdecc_values_smpte_time_get_subframes(base, pos);
        p->frames_per_second = jdksavdecc_values_smpte_time_get_frames_per_second(base, pos);
        p->drop_frame = jdksavdecc_values_smpte_time_get_drop_frame(base, pos);
        p->pull = jdksavdecc_values_smpte_time_get_pull(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_values_smpte_time structure to a network buffer.
 *
 *  - Clause 7.3.5.2.6
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to values_smpte_time structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_smpte_time_write(struct jdksavdecc_values_smpte_time const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_SMPTE_TIME_LEN);
    if (r >= 0) {
        jdksavdecc_values_smpte_time_set_hours(p->hours, base, pos);
        jdksavdecc_values_smpte_time_set_minutes(p->minutes, base, pos);
        jdksavdecc_values_smpte_time_set_seconds(p->seconds, base, pos);
        jdksavdecc_values_smpte_time_set_frames(p->frames, base, pos);
        jdksavdecc_values_smpte_time_set_subframes(p->subframes, base, pos);
        jdksavdecc_values_smpte_time_set_frames_per_second(p->frames_per_second, base, pos);
        jdksavdecc_values_smpte_time_set_drop_frame(p->drop_frame, base, pos);
        jdksavdecc_values_smpte_time_set_pull(p->pull, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup values_sample_rate Sample Rate Value Details - Clause 7.3.5.2.7
 */
/*@{*/

/**
 * Extract the uint32 value of the sample_rate field of the VALUES_SAMPLE_RATE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t sample_rate value
 */
static inline uint32_t jdksavdecc_values_sample_rate_get_sample_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_SAMPLE_RATE_OFFSET_SAMPLE_RATE);
}

/**
 * Store a uint32 value to the sample_rate field of the VALUES_SAMPLE_RATE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t sample_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_sample_rate_set_sample_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_SAMPLE_RATE_OFFSET_SAMPLE_RATE);
}

/*@}*/

/** \addtogroup values_sample_rate Sample Rate Value Details - Clause 7.3.5.2.7
 */
/*@{*/

/// Sample Rate Value Details - Clause 7.3.5.2.7
struct jdksavdecc_values_sample_rate {
    uint32_t sample_rate; /// @todo pull field
};

/**
 * Extract the jdksavdecc_values_sample_rate structure from a network buffer.
 *
 *  - Clause 7.3.5.2.7
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to values_sample_rate structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_sample_rate_read(struct jdksavdecc_values_sample_rate *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_SAMPLE_RATE_LEN);
    if (r >= 0) {
        p->sample_rate = jdksavdecc_values_sample_rate_get_sample_rate(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_values_sample_rate structure to a network buffer.
 *
 *  - Clause 7.3.5.2.7
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to values_sample_rate structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_sample_rate_write(struct jdksavdecc_values_sample_rate const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_SAMPLE_RATE_LEN);
    if (r >= 0) {
        jdksavdecc_values_sample_rate_set_sample_rate(p->sample_rate, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup values_gptp_time gPTP Time Value Details - Clause 7.3.5.2.8  */
/*@{*/

/**
 * Extract the gptp_seconds value of the gptp_seconds field of the
 *VALUES_GPTP_TIME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_gptp_seconds_t gptp_seconds value
 */
static inline struct jdksavdecc_gptp_seconds jdksavdecc_values_gptp_time_get_gptp_seconds(void const *base, ssize_t pos) {
    return jdksavdecc_gptp_seconds_get(base, pos + JDKSAVDECC_VALUES_GPTP_TIME_OFFSET_GPTP_SECONDS);
}

/**
 * Store a gptp_seconds value to the gptp_seconds field of the VALUES_GPTP_TIME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_gptp_seconds_t gptp_seconds value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_gptp_time_set_gptp_seconds(struct jdksavdecc_gptp_seconds v, void *base, ssize_t pos) {
    jdksavdecc_gptp_seconds_set(v, base, pos + JDKSAVDECC_VALUES_GPTP_TIME_OFFSET_GPTP_SECONDS);
}

/**
 * Extract the uint32 value of the gptp_nanoseconds field of the
 *VALUES_GPTP_TIME object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t gptp_nanoseconds value
 */
static inline uint32_t jdksavdecc_values_gptp_time_get_gptp_nanoseconds(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_GPTP_TIME_OFFSET_GPTP_NANOSECONDS);
}

/**
 * Store a uint32 value to the gptp_nanoseconds field of the VALUES_GPTP_TIME
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t gptp_nanoseconds value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_gptp_time_set_gptp_nanoseconds(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_GPTP_TIME_OFFSET_GPTP_NANOSECONDS);
}

/*@}*/

/** \addtogroup values_gptp_time gPTP Time Value Details - Clause 7.3.5.2.8  */
/*@{*/

/// gPTP Time Value Details - Clause 7.3.5.2.8
struct jdksavdecc_values_gptp_time {
    struct jdksavdecc_gptp_seconds gptp_seconds;
    uint32_t gptp_nanoseconds;
};

/**
 * Extract the jdksavdecc_values_gptp_time_t structure from a network buffer.
 *
 *  - Clause 7.3.5.2.8
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to values_gptp_time structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_gptp_time_read(struct jdksavdecc_values_gptp_time *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_GPTP_TIME_LEN);
    if (r >= 0) {
        p->gptp_seconds = jdksavdecc_values_gptp_time_get_gptp_seconds(base, pos);
        p->gptp_nanoseconds = jdksavdecc_values_gptp_time_get_gptp_nanoseconds(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_values_gptp_time structure to a network buffer.
 *
 *  - Clause 7.3.5.2.8
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to values_gptp_time structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_gptp_time_write(struct jdksavdecc_values_gptp_time const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_GPTP_TIME_LEN);
    if (r >= 0) {
        jdksavdecc_values_gptp_time_set_gptp_seconds(p->gptp_seconds, base, pos);
        jdksavdecc_values_gptp_time_set_gptp_nanoseconds(p->gptp_nanoseconds, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup values_vendor Vendor Value Details - Clause 7.3.5.2.9  */
/*@{*/

/**
 * Extract the eui64 value of the vendor_eui64 field of the VALUES_VENDOR object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_values_vendor_get_vendor_eui64(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_VALUES_VENDOR_OFFSET_VENDOR_EUI64);
}

/**
 * Store a eui64 value to the vendor_eui64 field of the VALUES_VENDOR object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_vendor_set_vendor_eui64(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_VALUES_VENDOR_OFFSET_VENDOR_EUI64);
}

/**
 * Extract the uint32 value of the blob_size field of the VALUES_VENDOR object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t blob_size value
 */
static inline uint32_t jdksavdecc_values_vendor_get_blob_size(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_VALUES_VENDOR_OFFSET_BLOB_SIZE);
}

/**
 * Store a uint32 value to the blob_size field of the VALUES_VENDOR object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t blob_size value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_values_vendor_set_blob_size(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_VALUES_VENDOR_OFFSET_BLOB_SIZE);
}

/*@}*/

/** \addtogroup values_vendor Vendor Value Details - Clause 7.3.5.2.9  */
/*@{*/

/// Vendor Value Details - Clause 7.3.5.2.9
struct jdksavdecc_values_vendor {
    struct jdksavdecc_eui64 vendor_eui64;
    uint16_t blob_size;
};

/**
 * Extract the jdksavdecc_values_vendor structure from a network buffer.
 *
 *  - Clause 7.3.5.2.9
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to values_vendor structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_vendor_read(struct jdksavdecc_values_vendor *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_VENDOR_LEN);
    if (r >= 0) {
        p->vendor_eui64 = jdksavdecc_values_vendor_get_vendor_eui64(base, pos);
        p->blob_size = jdksavdecc_values_vendor_get_blob_size(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_values_vendor_t structure to a network buffer.
 *
 *  - Clause 7.3.5.2.9
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to values_vendor structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_values_vendor_write(struct jdksavdecc_values_vendor const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VALUES_VENDOR_LEN);
    if (r >= 0) {
        jdksavdecc_values_vendor_set_vendor_eui64(p->vendor_eui64, base, pos);
        jdksavdecc_values_vendor_set_blob_size(p->blob_size, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup msrp_mappings_format msrp_mappings Format - Clause 7.4.40.2.1
 */
/*@{*/

/**
 * Extract the uint8 value of the traffic_class field of the
 *MSRP_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t traffic_class value
 */
static inline uint8_t jdksavdecc_msrp_mappings_format_get_traffic_class(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_TRAFFIC_CLASS);
}

/**
 * Store a uint8 value to the traffic_class field of the MSRP_MAPPINGS_FORMAT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t traffic_class value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_msrp_mappings_format_set_traffic_class(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_TRAFFIC_CLASS);
}

/**
 * Extract the uint8 value of the priority field of the MSRP_MAPPINGS_FORMAT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t priority value
 */
static inline uint8_t jdksavdecc_msrp_mappings_format_get_priority(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_PRIORITY);
}

/**
 * Store a uint8 value to the priority field of the MSRP_MAPPINGS_FORMAT object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t priority value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_msrp_mappings_format_set_priority(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_PRIORITY);
}

/**
 * Extract the uint16 value of the vlan_id field of the MSRP_MAPPINGS_FORMAT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t vlan_id value
 */
static inline uint16_t jdksavdecc_msrp_mappings_format_get_vlan_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_VLAN_ID);
}

/**
 * Store a uint16 value to the vlan_id field of the MSRP_MAPPINGS_FORMAT object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t vlan_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_msrp_mappings_format_set_vlan_id(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_MSRP_MAPPINGS_FORMAT_OFFSET_VLAN_ID);
}

/*@}*/

/** \addtogroup msrp_mappings_format msrp_mappings Format - Clause 7.4.40.2.1
 */
/*@{*/

/// msrp_mappings Format - Clause 7.4.40.2.1
struct jdksavdecc_msrp_mappings_format {
    uint8_t traffic_class;
    uint8_t priority;
    uint16_t vlan_id;
};

/**
 * Extract the jdksavdecc_msrp_mappings_format structure from a network buffer.
 *
 *  - Clause 7.4.40.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to msrp_mappings_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_msrp_mappings_format_read(struct jdksavdecc_msrp_mappings_format *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_MSRP_MAPPINGS_FORMAT_LEN);
    if (r >= 0) {
        p->traffic_class = jdksavdecc_msrp_mappings_format_get_traffic_class(base, pos);
        p->priority = jdksavdecc_msrp_mappings_format_get_priority(base, pos);
        p->vlan_id = jdksavdecc_msrp_mappings_format_get_vlan_id(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_msrp_mappings_format structure to a network buffer.
 *
 *  - Clause 7.4.40.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to msrp_mappings_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_msrp_mappings_format_write(struct jdksavdecc_msrp_mappings_format const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_MSRP_MAPPINGS_FORMAT_LEN);
    if (r >= 0) {
        jdksavdecc_msrp_mappings_format_set_traffic_class(p->traffic_class, base, pos);
        jdksavdecc_msrp_mappings_format_set_priority(p->priority, base, pos);
        jdksavdecc_msrp_mappings_format_set_vlan_id(p->vlan_id, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup audio_mappings_format Audio Mappings Format - Clause 7.4.44.2.1
 */
/*@{*/

/**
 * Extract the uint16 value of the mapping_stream_index field of the
 *AUDIO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_stream_index value
 */
static inline uint16_t jdksavdecc_audio_mappings_format_get_mapping_stream_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Store a uint16 value to the mapping_stream_index field of the
 *AUDIO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_stream_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mappings_format_set_mapping_stream_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Extract the uint16 value of the mapping_stream_channel field of the
 *AUDIO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_stream_channel value
 */
static inline uint16_t jdksavdecc_audio_mappings_format_get_mapping_stream_channel(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_CHANNEL);
}

/**
 * Store a uint16 value to the mapping_stream_channel field of the
 *AUDIO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_stream_channel value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mappings_format_set_mapping_stream_channel(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_CHANNEL);
}

/**
 * Extract the uint16 value of the mapping_cluster_offset field of the
 *AUDIO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_cluster_offset value
 */
static inline uint16_t jdksavdecc_audio_mappings_format_get_mapping_cluster_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/**
 * Store a uint16 value to the mapping_cluster_offset field of the
 *AUDIO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_cluster_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mappings_format_set_mapping_cluster_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/**
 * Extract the uint16 value of the mapping_cluster_channel field of the
 *AUDIO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_cluster_channel value
 */
static inline uint16_t jdksavdecc_audio_mappings_format_get_mapping_cluster_channel(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_CHANNEL);
}

/**
 * Store a uint16 value to the mapping_cluster_channel field of the
 *AUDIO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_cluster_channel value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_audio_mappings_format_set_mapping_cluster_channel(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_CHANNEL);
}

/*@}*/

/** \addtogroup audio_mappings_format Audio Mappings Format - Clause 7.4.44.2.1
 */
/*@{*/

/// Audio Mappings Format - Clause 7.4.44.2.1
struct jdksavdecc_audio_mappings_format {
    uint16_t mapping_stream_index;
    uint16_t mapping_stream_channel;
    uint16_t mapping_cluster_offset;
    uint16_t mapping_cluster_channel;
};

/**
 * Extract the jdksavdecc_audio_mappings_format structure from a network buffer.
 *
 *  - Clause 7.4.44.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to audio_mappings_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_audio_mappings_format_read(struct jdksavdecc_audio_mappings_format *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_LEN);
    if (r >= 0) {
        p->mapping_stream_index = jdksavdecc_audio_mappings_format_get_mapping_stream_index(base, pos);
        p->mapping_stream_channel = jdksavdecc_audio_mappings_format_get_mapping_stream_channel(base, pos);
        p->mapping_cluster_offset = jdksavdecc_audio_mappings_format_get_mapping_cluster_offset(base, pos);
        p->mapping_cluster_channel = jdksavdecc_audio_mappings_format_get_mapping_cluster_channel(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_audio_mappings_format structure to a network buffer.
 *
 *  - Clause 7.4.44.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to audio_mappings_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_audio_mappings_format_write(struct jdksavdecc_audio_mappings_format const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_AUDIO_MAPPINGS_FORMAT_LEN);
    if (r >= 0) {
        jdksavdecc_audio_mappings_format_set_mapping_stream_index(p->mapping_stream_index, base, pos);
        jdksavdecc_audio_mappings_format_set_mapping_stream_channel(p->mapping_stream_channel, base, pos);
        jdksavdecc_audio_mappings_format_set_mapping_cluster_offset(p->mapping_cluster_offset, base, pos);
        jdksavdecc_audio_mappings_format_set_mapping_cluster_channel(p->mapping_cluster_channel, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup video_mappings_format Video Mappings Format - Clause 7.4.47.2.1
 */
/*@{*/

/**
 * Extract the uint16 value of the mapping_stream_index field of the
 *VIDEO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_stream_index value
 */
static inline uint16_t jdksavdecc_video_mappings_format_get_mapping_stream_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Store a uint16 value to the mapping_stream_index field of the
 *VIDEO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_stream_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mappings_format_set_mapping_stream_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_STREAM_INDEX);
}

/**
 * Extract the uint16 value of the mapping_program_stream field of the
 *VIDEO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_program_stream value
 */
static inline uint16_t jdksavdecc_video_mappings_format_get_mapping_program_stream(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_PROGRAM_STREAM);
}

/**
 * Store a uint16 value to the mapping_program_stream field of the
 *VIDEO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_program_stream value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mappings_format_set_mapping_program_stream(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_PROGRAM_STREAM);
}

/**
 * Extract the uint16 value of the mapping_elementary_stream field of the
 *VIDEO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_elementary_stream value
 */
static inline uint16_t jdksavdecc_video_mappings_format_get_mapping_elementary_stream(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_ELEMENTARY_STREAM);
}

/**
 * Store a uint16 value to the mapping_elementary_stream field of the
 *VIDEO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_elementary_stream value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mappings_format_set_mapping_elementary_stream(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_ELEMENTARY_STREAM);
}

/**
 * Extract the uint16 value of the mapping_cluster_offset field of the
 *VIDEO_MAPPINGS_FORMAT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mapping_cluster_offset value
 */
static inline uint16_t jdksavdecc_video_mappings_format_get_mapping_cluster_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/**
 * Store a uint16 value to the mapping_cluster_offset field of the
 *VIDEO_MAPPINGS_FORMAT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mapping_cluster_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_video_mappings_format_set_mapping_cluster_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_OFFSET_MAPPING_CLUSTER_OFFSET);
}

/*@}*/

/** \addtogroup video_mappings_format Video Mappings Format - Clause 7.4.47.2.1
 */
/*@{*/

/// Video Mappings Format - Clause 7.4.47.2.1
struct jdksavdecc_video_mappings_format {
    uint16_t mapping_stream_index;
    uint16_t mapping_program_stream;
    uint16_t mapping_elementary_stream;
    uint16_t mapping_cluster_offset;
};

/**
 * Extract the jdksavdecc_video_mappings_format structure from a network buffer.
 *
 *  - Clause 7.4.47.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to video_mappings_format structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_video_mappings_format_read(struct jdksavdecc_video_mappings_format *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_LEN);
    if (r >= 0) {
        p->mapping_stream_index = jdksavdecc_video_mappings_format_get_mapping_stream_index(base, pos);
        p->mapping_program_stream = jdksavdecc_video_mappings_format_get_mapping_program_stream(base, pos);
        p->mapping_elementary_stream = jdksavdecc_video_mappings_format_get_mapping_elementary_stream(base, pos);
        p->mapping_cluster_offset = jdksavdecc_video_mappings_format_get_mapping_cluster_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_video_mappings_format structure to a network buffer.
 *
 *  - Clause 7.4.47.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to video_mappings_format structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_video_mappings_format_write(struct jdksavdecc_video_mappings_format const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_VIDEO_MAPPINGS_FORMAT_LEN);
    if (r >= 0) {
        jdksavdecc_video_mappings_format_set_mapping_stream_index(p->mapping_stream_index, base, pos);
        jdksavdecc_video_mappings_format_set_mapping_program_stream(p->mapping_program_stream, base, pos);
        jdksavdecc_video_mappings_format_set_mapping_elementary_stream(p->mapping_elementary_stream, base, pos);
        jdksavdecc_video_mappings_format_set_mapping_cluster_offset(p->mapping_cluster_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_entity ENTITY Descriptor - Clause 7.2.1  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the eui64 value of the entity_entity_id field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 entity_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_entity_get_entity_entity_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_ENTITY_ID);
}

/**
 * Store a eui64 value to the entity_entity_id field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 entity_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_entity_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_ENTITY_ID);
}

/**
 * Extract the uint32 value of the vendor_id field of the DESCRIPTOR_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t vendor_id value
 */
static inline uint32_t jdksavdecc_descriptor_entity_get_vendor_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_VENDOR_ID);
}

/**
 * Store a uint32 value to the vendor_id field of the DESCRIPTOR_ENTITY object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t vendor_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_vendor_id(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_VENDOR_ID);
}

/**
 * Extract the uint32 value of the entity_model_id field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t entity_model_id value
 */
static inline uint32_t jdksavdecc_descriptor_entity_get_entity_model_id(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_MODEL_ID);
}

/**
 * Store a uint32 value to the entity_model_id field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t entity_model_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_entity_model_id(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_MODEL_ID);
}

/**
 * Extract the uint32 value of the entity_capabilities field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t entity_capabilities value
 */
static inline uint32_t jdksavdecc_descriptor_entity_get_entity_capabilities(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_CAPABILITIES);
}

/**
 * Store a uint32 value to the entity_capabilities field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t entity_capabilities value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_entity_capabilities(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_CAPABILITIES);
}

/**
 * Extract the uint16 value of the talker_stream_sources field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t talker_stream_sources value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_talker_stream_sources(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_TALKER_STREAM_SOURCES);
}

/**
 * Store a uint16 value to the talker_stream_sources field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t talker_stream_sources value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_talker_stream_sources(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_TALKER_STREAM_SOURCES);
}

/**
 * Extract the uint16 value of the talker_capabilities field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t talker_capabilities value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_talker_capabilities(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_TALKER_CAPABILITIES);
}

/**
 * Store a uint16 value to the talker_capabilities field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t talker_capabilities value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_talker_capabilities(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_TALKER_CAPABILITIES);
}

/**
 * Extract the uint16 value of the listener_stream_sinks field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t listener_stream_sinks value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_listener_stream_sinks(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_LISTENER_STREAM_SINKS);
}

/**
 * Store a uint16 value to the listener_stream_sinks field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t listener_stream_sinks value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_listener_stream_sinks(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_LISTENER_STREAM_SINKS);
}

/**
 * Extract the uint16 value of the listener_capabilities field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t listener_capabilities value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_listener_capabilities(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_LISTENER_CAPABILITIES);
}

/**
 * Store a uint16 value to the listener_capabilities field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t listener_capabilities value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_listener_capabilities(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_LISTENER_CAPABILITIES);
}

/**
 * Extract the uint32 value of the controller_capabilities field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t controller_capabilities value
 */
static inline uint32_t jdksavdecc_descriptor_entity_get_controller_capabilities(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CONTROLLER_CAPABILITIES);
}

/**
 * Store a uint32 value to the controller_capabilities field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t controller_capabilities value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_controller_capabilities(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CONTROLLER_CAPABILITIES);
}

/**
 * Extract the uint32 value of the available_index field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t available_index value
 */
static inline uint32_t jdksavdecc_descriptor_entity_get_available_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_AVAILABLE_INDEX);
}

/**
 * Store a uint32 value to the available_index field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t available_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_available_index(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_AVAILABLE_INDEX);
}

/**
 * Extract the eui64 value of the association_id field of the DESCRIPTOR_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 association_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_entity_get_association_id(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ASSOCIATION_ID);
}

/**
 * Store a eui64 value to the association_id field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 association_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_association_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ASSOCIATION_ID);
}

/**
 * Extract the string value of the entity_name field of the DESCRIPTOR_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t entity_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_entity_get_entity_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_NAME);
}

/**
 * Store a string value to the entity_name field of the DESCRIPTOR_ENTITY object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t entity_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_entity_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_ENTITY_NAME);
}

/**
 * Extract the uint16 value of the vendor_name_string field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t vendor_name_string value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_vendor_name_string(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_VENDOR_NAME_STRING);
}

/**
 * Store a uint16 value to the vendor_name_string field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t vendor_name_string value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_vendor_name_string(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_VENDOR_NAME_STRING);
}

/**
 * Extract the uint16 value of the model_name_string field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t model_name_string value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_model_name_string(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_MODEL_NAME_STRING);
}

/**
 * Store a uint16 value to the model_name_string field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t model_name_string value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_model_name_string(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_MODEL_NAME_STRING);
}

/**
 * Extract the string value of the firmware_version field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t firmware_version value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_entity_get_firmware_version(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_FIRMWARE_VERSION);
}

/**
 * Store a string value to the firmware_version field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t firmware_version value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_firmware_version(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_FIRMWARE_VERSION);
}

/**
 * Extract the string value of the group_name field of the DESCRIPTOR_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t group_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_entity_get_group_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_GROUP_NAME);
}

/**
 * Store a string value to the group_name field of the DESCRIPTOR_ENTITY object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t group_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_group_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_GROUP_NAME);
}

/**
 * Extract the string value of the serial_number field of the DESCRIPTOR_ENTITY
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t serial_number value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_entity_get_serial_number(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_SERIAL_NUMBER);
}

/**
 * Store a string value to the serial_number field of the DESCRIPTOR_ENTITY
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t serial_number value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_serial_number(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_SERIAL_NUMBER);
}

/**
 * Extract the uint16 value of the configurations_count field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t configurations_count value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_configurations_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CONFIGURATIONS_COUNT);
}

/**
 * Store a uint16 value to the configurations_count field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t configurations_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_configurations_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CONFIGURATIONS_COUNT);
}

/**
 * Extract the uint16 value of the current_configuration field of the
 *DESCRIPTOR_ENTITY object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t current_configuration value
 */
static inline uint16_t jdksavdecc_descriptor_entity_get_current_configuration(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CURRENT_CONFIGURATION);
}

/**
 * Store a uint16 value to the current_configuration field of the
 *DESCRIPTOR_ENTITY object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t current_configuration value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_entity_set_current_configuration(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_ENTITY_OFFSET_CURRENT_CONFIGURATION);
}

/*@}*/

/** \addtogroup descriptor_entity ENTITY Descriptor - Clause 7.2.1  */
/*@{*/

/// ENTITY Descriptor - Clause 7.2.1
struct jdksavdecc_descriptor_entity {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_eui64 entity_entity_id;
    uint32_t vendor_id;
    uint32_t entity_model_id;
    uint32_t entity_capabilities;
    uint16_t talker_stream_sources;
    uint16_t talker_capabilities;
    uint16_t listener_stream_sinks;
    uint16_t listener_capabilities;
    uint32_t controller_capabilities;
    uint32_t available_index;
    struct jdksavdecc_eui64 association_id;
    struct jdksavdecc_string entity_name;
    uint16_t vendor_name_string;
    uint16_t model_name_string;
    struct jdksavdecc_string firmware_version;
    struct jdksavdecc_string group_name;
    struct jdksavdecc_string serial_number;
    uint16_t configurations_count;
    uint16_t current_configuration;
};

/**
 * Extract the jdksavdecc_descriptor_entity structure from a network buffer.
 *
 *  - Clause 7.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_entity structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_entity_read(struct jdksavdecc_descriptor_entity *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_ENTITY_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_entity_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_entity_get_descriptor_index(base, pos);
        p->entity_entity_id = jdksavdecc_descriptor_entity_get_entity_entity_id(base, pos);
        p->vendor_id = jdksavdecc_descriptor_entity_get_vendor_id(base, pos);
        p->entity_model_id = jdksavdecc_descriptor_entity_get_entity_model_id(base, pos);
        p->entity_capabilities = jdksavdecc_descriptor_entity_get_entity_capabilities(base, pos);
        p->talker_stream_sources = jdksavdecc_descriptor_entity_get_talker_stream_sources(base, pos);
        p->talker_capabilities = jdksavdecc_descriptor_entity_get_talker_capabilities(base, pos);
        p->listener_stream_sinks = jdksavdecc_descriptor_entity_get_listener_stream_sinks(base, pos);
        p->listener_capabilities = jdksavdecc_descriptor_entity_get_listener_capabilities(base, pos);
        p->controller_capabilities = jdksavdecc_descriptor_entity_get_controller_capabilities(base, pos);
        p->available_index = jdksavdecc_descriptor_entity_get_available_index(base, pos);
        p->association_id = jdksavdecc_descriptor_entity_get_association_id(base, pos);
        p->entity_name = jdksavdecc_descriptor_entity_get_entity_name(base, pos);
        p->vendor_name_string = jdksavdecc_descriptor_entity_get_vendor_name_string(base, pos);
        p->model_name_string = jdksavdecc_descriptor_entity_get_model_name_string(base, pos);
        p->firmware_version = jdksavdecc_descriptor_entity_get_firmware_version(base, pos);
        p->group_name = jdksavdecc_descriptor_entity_get_group_name(base, pos);
        p->serial_number = jdksavdecc_descriptor_entity_get_serial_number(base, pos);
        p->configurations_count = jdksavdecc_descriptor_entity_get_configurations_count(base, pos);
        p->current_configuration = jdksavdecc_descriptor_entity_get_current_configuration(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_entity structure to a network buffer.
 *
 *  - Clause 7.2.1
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_entity structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_entity_write(struct jdksavdecc_descriptor_entity const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_ENTITY_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_entity_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_entity_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_entity_set_entity_entity_id(p->entity_entity_id, base, pos);
        jdksavdecc_descriptor_entity_set_vendor_id(p->vendor_id, base, pos);
        jdksavdecc_descriptor_entity_set_entity_model_id(p->entity_model_id, base, pos);
        jdksavdecc_descriptor_entity_set_entity_capabilities(p->entity_capabilities, base, pos);
        jdksavdecc_descriptor_entity_set_talker_stream_sources(p->talker_stream_sources, base, pos);
        jdksavdecc_descriptor_entity_set_talker_capabilities(p->talker_capabilities, base, pos);
        jdksavdecc_descriptor_entity_set_listener_stream_sinks(p->listener_stream_sinks, base, pos);
        jdksavdecc_descriptor_entity_set_listener_capabilities(p->listener_capabilities, base, pos);
        jdksavdecc_descriptor_entity_set_controller_capabilities(p->controller_capabilities, base, pos);
        jdksavdecc_descriptor_entity_set_available_index(p->available_index, base, pos);
        jdksavdecc_descriptor_entity_set_association_id(p->association_id, base, pos);
        jdksavdecc_descriptor_entity_set_entity_name(p->entity_name, base, pos);
        jdksavdecc_descriptor_entity_set_vendor_name_string(p->vendor_name_string, base, pos);
        jdksavdecc_descriptor_entity_set_model_name_string(p->model_name_string, base, pos);
        jdksavdecc_descriptor_entity_set_firmware_version(p->firmware_version, base, pos);
        jdksavdecc_descriptor_entity_set_group_name(p->group_name, base, pos);
        jdksavdecc_descriptor_entity_set_serial_number(p->serial_number, base, pos);
        jdksavdecc_descriptor_entity_set_configurations_count(p->configurations_count, base, pos);
        jdksavdecc_descriptor_entity_set_current_configuration(p->current_configuration, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_configuration CONFIGURATION Descriptor - Clause 7.2.2
 */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_configuration_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_configuration_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_configuration_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_configuration_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_configuration_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_CONFIGURATION
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_configuration_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_configuration_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_configuration_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the descriptor_counts_count field of the
 *DESCRIPTOR_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_counts_count value
 */
static inline uint16_t jdksavdecc_descriptor_configuration_get_descriptor_counts_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS_COUNT);
}

/**
 * Store a uint16 value to the descriptor_counts_count field of the
 *DESCRIPTOR_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_counts_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_configuration_set_descriptor_counts_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS_COUNT);
}

/**
 * Extract the uint16 value of the descriptor_counts_offset field of the
 *DESCRIPTOR_CONFIGURATION object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_counts_offset value
 */
static inline uint16_t jdksavdecc_descriptor_configuration_get_descriptor_counts_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS_OFFSET);
}

/**
 * Store a uint16 value to the descriptor_counts_offset field of the
 *DESCRIPTOR_CONFIGURATION object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_counts_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_configuration_set_descriptor_counts_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONFIGURATION_OFFSET_DESCRIPTOR_COUNTS_OFFSET);
}

/*@}*/

/** \addtogroup descriptor_configuration CONFIGURATION Descriptor - Clause 7.2.2
 */
/*@{*/

/// CONFIGURATION Descriptor - Clause 7.2.2
struct jdksavdecc_descriptor_configuration {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t descriptor_counts_count;
    uint16_t descriptor_counts_offset;
};

/**
 * Extract the jdksavdecc_descriptor_configuration structure from a network
 *buffer.
 *
 *  - Clause 7.2.2
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_configuration structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_configuration_read(struct jdksavdecc_descriptor_configuration *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CONFIGURATION_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_configuration_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_configuration_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_configuration_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_configuration_get_localized_description(base, pos);
        p->descriptor_counts_count = jdksavdecc_descriptor_configuration_get_descriptor_counts_count(base, pos);
        p->descriptor_counts_offset = jdksavdecc_descriptor_configuration_get_descriptor_counts_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_configuration structure to a network buffer.
 *
 *  - Clause 7.2.2
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_configuration structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_configuration_write(struct jdksavdecc_descriptor_configuration const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CONFIGURATION_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_configuration_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_configuration_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_configuration_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_configuration_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_configuration_set_descriptor_counts_count(p->descriptor_counts_count, base, pos);
        jdksavdecc_descriptor_configuration_set_descriptor_counts_offset(p->descriptor_counts_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_audio AUDIO_UNIT Descriptor - Clause 7.2.3  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_audio_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_AUDIO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the number_of_stream_input_ports field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_stream_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_stream_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_stream_input_ports field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_stream_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_stream_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_stream_input_port field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_stream_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_stream_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_STREAM_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_stream_input_port field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_stream_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_stream_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_STREAM_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_stream_output_ports field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_stream_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_stream_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_stream_output_ports field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_stream_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_stream_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_stream_output_port field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_stream_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_stream_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_STREAM_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_stream_output_port field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_stream_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_stream_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_STREAM_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_external_input_ports field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_external_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_external_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_external_input_ports field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_external_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_external_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_external_input_port field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_external_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_external_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_EXTERNAL_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_external_input_port field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_external_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_external_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_EXTERNAL_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_external_output_ports field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_external_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_external_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_external_output_ports field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_external_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_external_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_external_output_port field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_external_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_external_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_EXTERNAL_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_external_output_port field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_external_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_external_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_EXTERNAL_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_internal_input_ports field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_internal_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_internal_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_internal_input_ports field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_internal_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_internal_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_internal_input_port field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_internal_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_internal_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_INTERNAL_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_internal_input_port field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_internal_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_internal_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_INTERNAL_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_internal_output_ports field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_internal_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_internal_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_internal_output_ports field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_internal_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_internal_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_internal_output_port field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_internal_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_internal_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_INTERNAL_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_internal_output_port field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_internal_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_internal_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_INTERNAL_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the DESCRIPTOR_AUDIO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the number_of_signal_selectors field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_signal_selectors value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_signal_selectors(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_SIGNAL_SELECTORS);
}

/**
 * Store a uint16 value to the number_of_signal_selectors field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_signal_selectors value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_signal_selectors(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_SIGNAL_SELECTORS);
}

/**
 * Extract the uint16 value of the base_signal_selector field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_signal_selector value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_signal_selector(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_SIGNAL_SELECTOR);
}

/**
 * Store a uint16 value to the base_signal_selector field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_signal_selector value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_signal_selector(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_SIGNAL_SELECTOR);
}

/**
 * Extract the uint16 value of the number_of_mixers field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mixers value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_mixers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MIXERS);
}

/**
 * Store a uint16 value to the number_of_mixers field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mixers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_mixers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MIXERS);
}

/**
 * Extract the uint16 value of the base_mixer field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_mixer value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_mixer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MIXER);
}

/**
 * Store a uint16 value to the base_mixer field of the DESCRIPTOR_AUDIO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_mixer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_mixer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MIXER);
}

/**
 * Extract the uint16 value of the number_of_matrices field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_matrices value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_matrices(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MATRICES);
}

/**
 * Store a uint16 value to the number_of_matrices field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_matrices value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_matrices(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MATRICES);
}

/**
 * Extract the uint16 value of the base_matrix field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_matrix value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_matrix(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MATRIX);
}

/**
 * Store a uint16 value to the base_matrix field of the DESCRIPTOR_AUDIO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_matrix value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_matrix(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MATRIX);
}

/**
 * Extract the uint16 value of the number_of_splitters field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_splitters value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_splitters(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_SPLITTERS);
}

/**
 * Store a uint16 value to the number_of_splitters field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_splitters value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_splitters(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_SPLITTERS);
}

/**
 * Extract the uint16 value of the base_splitter field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_splitter value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_splitter(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_SPLITTER);
}

/**
 * Store a uint16 value to the base_splitter field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_splitter value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_splitter(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_SPLITTER);
}

/**
 * Extract the uint16 value of the number_of_combiners field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_combiners value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_combiners(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_COMBINERS);
}

/**
 * Store a uint16 value to the number_of_combiners field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_combiners value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_combiners(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_COMBINERS);
}

/**
 * Extract the uint16 value of the base_combiner field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_combiner value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_combiner(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_COMBINER);
}

/**
 * Store a uint16 value to the base_combiner field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_combiner value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_combiner(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_COMBINER);
}

/**
 * Extract the uint16 value of the number_of_demultiplexers field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_demultiplexers value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_demultiplexers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_DEMULTIPLEXERS);
}

/**
 * Store a uint16 value to the number_of_demultiplexers field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_demultiplexers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_demultiplexers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_DEMULTIPLEXERS);
}

/**
 * Extract the uint16 value of the base_demultiplexer field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_demultiplexer value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_demultiplexer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_DEMULTIPLEXER);
}

/**
 * Store a uint16 value to the base_demultiplexer field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_demultiplexer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_demultiplexer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_DEMULTIPLEXER);
}

/**
 * Extract the uint16 value of the number_of_multiplexers field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_multiplexers value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_multiplexers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MULTIPLEXERS);
}

/**
 * Store a uint16 value to the number_of_multiplexers field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_multiplexers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_multiplexers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_MULTIPLEXERS);
}

/**
 * Extract the uint16 value of the base_multiplexer field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_multiplexer value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_multiplexer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MULTIPLEXER);
}

/**
 * Store a uint16 value to the base_multiplexer field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_multiplexer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_multiplexer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_MULTIPLEXER);
}

/**
 * Extract the uint16 value of the number_of_transcoders field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_transcoders value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_transcoders(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_TRANSCODERS);
}

/**
 * Store a uint16 value to the number_of_transcoders field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_transcoders value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_transcoders(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_TRANSCODERS);
}

/**
 * Extract the uint16 value of the base_transcoder field of the DESCRIPTOR_AUDIO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_transcoder value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_transcoder(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_TRANSCODER);
}

/**
 * Store a uint16 value to the base_transcoder field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_transcoder value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_transcoder(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_TRANSCODER);
}

/**
 * Extract the uint16 value of the number_of_control_blocks field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_control_blocks value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_number_of_control_blocks(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_CONTROL_BLOCKS);
}

/**
 * Store a uint16 value to the number_of_control_blocks field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_control_blocks value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_number_of_control_blocks(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_NUMBER_OF_CONTROL_BLOCKS);
}

/**
 * Extract the uint16 value of the base_control_block field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control_block value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_base_control_block(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_CONTROL_BLOCK);
}

/**
 * Store a uint16 value to the base_control_block field of the DESCRIPTOR_AUDIO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control_block value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_base_control_block(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_BASE_CONTROL_BLOCK);
}

/**
 * Extract the uint32 value of the current_sampling_rate field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t current_sampling_rate value
 */
static inline uint32_t jdksavdecc_descriptor_audio_get_current_sampling_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_CURRENT_SAMPLING_RATE);
}

/**
 * Store a uint32 value to the current_sampling_rate field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t current_sampling_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_current_sampling_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_CURRENT_SAMPLING_RATE);
}

/**
 * Extract the uint16 value of the sampling_rates_offset field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sampling_rates_offset value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_sampling_rates_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES_OFFSET);
}

/**
 * Store a uint16 value to the sampling_rates_offset field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sampling_rates_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_sampling_rates_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES_OFFSET);
}

/**
 * Extract the uint16 value of the sampling_rates_count field of the
 *DESCRIPTOR_AUDIO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sampling_rates_count value
 */
static inline uint16_t jdksavdecc_descriptor_audio_get_sampling_rates_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES_COUNT);
}

/**
 * Store a uint16 value to the sampling_rates_count field of the
 *DESCRIPTOR_AUDIO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sampling_rates_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_set_sampling_rates_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_OFFSET_SAMPLING_RATES_COUNT);
}

/*@}*/

/** \addtogroup descriptor_audio AUDIO_UNIT Descriptor - Clause 7.2.3  */
/*@{*/

/// AUDIO_UNIT Descriptor - Clause 7.2.3
struct jdksavdecc_descriptor_audio {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t clock_domain_index;
    uint16_t number_of_stream_input_ports;
    uint16_t base_stream_input_port;
    uint16_t number_of_stream_output_ports;
    uint16_t base_stream_output_port;
    uint16_t number_of_external_input_ports;
    uint16_t base_external_input_port;
    uint16_t number_of_external_output_ports;
    uint16_t base_external_output_port;
    uint16_t number_of_internal_input_ports;
    uint16_t base_internal_input_port;
    uint16_t number_of_internal_output_ports;
    uint16_t base_internal_output_port;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t number_of_signal_selectors;
    uint16_t base_signal_selector;
    uint16_t number_of_mixers;
    uint16_t base_mixer;
    uint16_t number_of_matrices;
    uint16_t base_matrix;
    uint16_t number_of_splitters;
    uint16_t base_splitter;
    uint16_t number_of_combiners;
    uint16_t base_combiner;
    uint16_t number_of_demultiplexers;
    uint16_t base_demultiplexer;
    uint16_t number_of_multiplexers;
    uint16_t base_multiplexer;
    uint16_t number_of_transcoders;
    uint16_t base_transcoder;
    uint16_t number_of_control_blocks;
    uint16_t base_control_block;
    uint32_t current_sampling_rate;
    uint16_t sampling_rates_offset;
    uint16_t sampling_rates_count;
};

/**
 * Extract the jdksavdecc_descriptor_audio structure from a network buffer.
 *
 *  - Clause 7.2.3
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_audio structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_audio_read(struct jdksavdecc_descriptor_audio *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AUDIO_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_audio_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_audio_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_audio_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_audio_get_localized_description(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_audio_get_clock_domain_index(base, pos);
        p->number_of_stream_input_ports = jdksavdecc_descriptor_audio_get_number_of_stream_input_ports(base, pos);
        p->base_stream_input_port = jdksavdecc_descriptor_audio_get_base_stream_input_port(base, pos);
        p->number_of_stream_output_ports = jdksavdecc_descriptor_audio_get_number_of_stream_output_ports(base, pos);
        p->base_stream_output_port = jdksavdecc_descriptor_audio_get_base_stream_output_port(base, pos);
        p->number_of_external_input_ports = jdksavdecc_descriptor_audio_get_number_of_external_input_ports(base, pos);
        p->base_external_input_port = jdksavdecc_descriptor_audio_get_base_external_input_port(base, pos);
        p->number_of_external_output_ports = jdksavdecc_descriptor_audio_get_number_of_external_output_ports(base, pos);
        p->base_external_output_port = jdksavdecc_descriptor_audio_get_base_external_output_port(base, pos);
        p->number_of_internal_input_ports = jdksavdecc_descriptor_audio_get_number_of_internal_input_ports(base, pos);
        p->base_internal_input_port = jdksavdecc_descriptor_audio_get_base_internal_input_port(base, pos);
        p->number_of_internal_output_ports = jdksavdecc_descriptor_audio_get_number_of_internal_output_ports(base, pos);
        p->base_internal_output_port = jdksavdecc_descriptor_audio_get_base_internal_output_port(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_audio_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_audio_get_base_control(base, pos);
        p->number_of_signal_selectors = jdksavdecc_descriptor_audio_get_number_of_signal_selectors(base, pos);
        p->base_signal_selector = jdksavdecc_descriptor_audio_get_base_signal_selector(base, pos);
        p->number_of_mixers = jdksavdecc_descriptor_audio_get_number_of_mixers(base, pos);
        p->base_mixer = jdksavdecc_descriptor_audio_get_base_mixer(base, pos);
        p->number_of_matrices = jdksavdecc_descriptor_audio_get_number_of_matrices(base, pos);
        p->base_matrix = jdksavdecc_descriptor_audio_get_base_matrix(base, pos);
        p->number_of_splitters = jdksavdecc_descriptor_audio_get_number_of_splitters(base, pos);
        p->base_splitter = jdksavdecc_descriptor_audio_get_base_splitter(base, pos);
        p->number_of_combiners = jdksavdecc_descriptor_audio_get_number_of_combiners(base, pos);
        p->base_combiner = jdksavdecc_descriptor_audio_get_base_combiner(base, pos);
        p->number_of_demultiplexers = jdksavdecc_descriptor_audio_get_number_of_demultiplexers(base, pos);
        p->base_demultiplexer = jdksavdecc_descriptor_audio_get_base_demultiplexer(base, pos);
        p->number_of_multiplexers = jdksavdecc_descriptor_audio_get_number_of_multiplexers(base, pos);
        p->base_multiplexer = jdksavdecc_descriptor_audio_get_base_multiplexer(base, pos);
        p->number_of_transcoders = jdksavdecc_descriptor_audio_get_number_of_transcoders(base, pos);
        p->base_transcoder = jdksavdecc_descriptor_audio_get_base_transcoder(base, pos);
        p->number_of_control_blocks = jdksavdecc_descriptor_audio_get_number_of_control_blocks(base, pos);
        p->base_control_block = jdksavdecc_descriptor_audio_get_base_control_block(base, pos);
        p->current_sampling_rate = jdksavdecc_descriptor_audio_get_current_sampling_rate(base, pos);
        p->sampling_rates_offset = jdksavdecc_descriptor_audio_get_sampling_rates_offset(base, pos);
        p->sampling_rates_count = jdksavdecc_descriptor_audio_get_sampling_rates_count(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_audio structure to a network buffer.
 *
 *  - Clause 7.2.3
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_audio structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_audio_write(struct jdksavdecc_descriptor_audio const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AUDIO_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_audio_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_audio_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_audio_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_audio_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_audio_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_stream_input_ports(p->number_of_stream_input_ports, base, pos);
        jdksavdecc_descriptor_audio_set_base_stream_input_port(p->base_stream_input_port, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_stream_output_ports(p->number_of_stream_output_ports, base, pos);
        jdksavdecc_descriptor_audio_set_base_stream_output_port(p->base_stream_output_port, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_external_input_ports(p->number_of_external_input_ports, base, pos);
        jdksavdecc_descriptor_audio_set_base_external_input_port(p->base_external_input_port, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_external_output_ports(p->number_of_external_output_ports, base, pos);
        jdksavdecc_descriptor_audio_set_base_external_output_port(p->base_external_output_port, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_internal_input_ports(p->number_of_internal_input_ports, base, pos);
        jdksavdecc_descriptor_audio_set_base_internal_input_port(p->base_internal_input_port, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_internal_output_ports(p->number_of_internal_output_ports, base, pos);
        jdksavdecc_descriptor_audio_set_base_internal_output_port(p->base_internal_output_port, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_audio_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_signal_selectors(p->number_of_signal_selectors, base, pos);
        jdksavdecc_descriptor_audio_set_base_signal_selector(p->base_signal_selector, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_mixers(p->number_of_mixers, base, pos);
        jdksavdecc_descriptor_audio_set_base_mixer(p->base_mixer, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_matrices(p->number_of_matrices, base, pos);
        jdksavdecc_descriptor_audio_set_base_matrix(p->base_matrix, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_splitters(p->number_of_splitters, base, pos);
        jdksavdecc_descriptor_audio_set_base_splitter(p->base_splitter, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_combiners(p->number_of_combiners, base, pos);
        jdksavdecc_descriptor_audio_set_base_combiner(p->base_combiner, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_demultiplexers(p->number_of_demultiplexers, base, pos);
        jdksavdecc_descriptor_audio_set_base_demultiplexer(p->base_demultiplexer, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_multiplexers(p->number_of_multiplexers, base, pos);
        jdksavdecc_descriptor_audio_set_base_multiplexer(p->base_multiplexer, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_transcoders(p->number_of_transcoders, base, pos);
        jdksavdecc_descriptor_audio_set_base_transcoder(p->base_transcoder, base, pos);
        jdksavdecc_descriptor_audio_set_number_of_control_blocks(p->number_of_control_blocks, base, pos);
        jdksavdecc_descriptor_audio_set_base_control_block(p->base_control_block, base, pos);
        jdksavdecc_descriptor_audio_set_current_sampling_rate(p->current_sampling_rate, base, pos);
        jdksavdecc_descriptor_audio_set_sampling_rates_offset(p->sampling_rates_offset, base, pos);
        jdksavdecc_descriptor_audio_set_sampling_rates_count(p->sampling_rates_count, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_video VIDEO_UNIT Descriptor - Clause 7.2.4  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_video_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_VIDEO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the number_of_stream_input_ports field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_stream_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_stream_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_stream_input_ports field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_stream_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_stream_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_stream_input_port field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_stream_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_stream_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_STREAM_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_stream_input_port field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_stream_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_stream_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_STREAM_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_stream_output_ports field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_stream_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_stream_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_stream_output_ports field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_stream_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_stream_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_stream_output_port field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_stream_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_stream_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_STREAM_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_stream_output_port field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_stream_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_stream_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_STREAM_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_external_input_ports field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_external_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_external_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_external_input_ports field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_external_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_external_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_external_input_port field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_external_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_external_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_EXTERNAL_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_external_input_port field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_external_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_external_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_EXTERNAL_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_external_output_ports field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_external_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_external_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_external_output_ports field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_external_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_external_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_external_output_port field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_external_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_external_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_EXTERNAL_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_external_output_port field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_external_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_external_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_EXTERNAL_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_internal_input_ports field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_internal_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_internal_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_internal_input_ports field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_internal_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_internal_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_internal_input_port field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_internal_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_internal_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_INTERNAL_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_internal_input_port field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_internal_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_internal_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_INTERNAL_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_internal_output_ports field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_internal_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_internal_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_internal_output_ports field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_internal_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_internal_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_internal_output_port field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_internal_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_internal_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_INTERNAL_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_internal_output_port field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_internal_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_internal_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_INTERNAL_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the DESCRIPTOR_VIDEO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the number_of_signal_selectors field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_signal_selectors value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_signal_selectors(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_SIGNAL_SELECTORS);
}

/**
 * Store a uint16 value to the number_of_signal_selectors field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_signal_selectors value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_signal_selectors(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_SIGNAL_SELECTORS);
}

/**
 * Extract the uint16 value of the base_signal_selector field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_signal_selector value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_signal_selector(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_SIGNAL_SELECTOR);
}

/**
 * Store a uint16 value to the base_signal_selector field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_signal_selector value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_signal_selector(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_SIGNAL_SELECTOR);
}

/**
 * Extract the uint16 value of the number_of_mixers field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mixers value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_mixers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MIXERS);
}

/**
 * Store a uint16 value to the number_of_mixers field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mixers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_mixers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MIXERS);
}

/**
 * Extract the uint16 value of the base_mixer field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_mixer value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_mixer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MIXER);
}

/**
 * Store a uint16 value to the base_mixer field of the DESCRIPTOR_VIDEO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_mixer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_mixer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MIXER);
}

/**
 * Extract the uint16 value of the number_of_matrices field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_matrices value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_matrices(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MATRICES);
}

/**
 * Store a uint16 value to the number_of_matrices field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_matrices value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_matrices(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MATRICES);
}

/**
 * Extract the uint16 value of the base_matrix field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_matrix value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_matrix(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MATRIX);
}

/**
 * Store a uint16 value to the base_matrix field of the DESCRIPTOR_VIDEO object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_matrix value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_matrix(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MATRIX);
}

/**
 * Extract the uint16 value of the number_of_splitters field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_splitters value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_splitters(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_SPLITTERS);
}

/**
 * Store a uint16 value to the number_of_splitters field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_splitters value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_splitters(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_SPLITTERS);
}

/**
 * Extract the uint16 value of the base_splitter field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_splitter value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_splitter(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_SPLITTER);
}

/**
 * Store a uint16 value to the base_splitter field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_splitter value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_splitter(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_SPLITTER);
}

/**
 * Extract the uint16 value of the number_of_combiners field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_combiners value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_combiners(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_COMBINERS);
}

/**
 * Store a uint16 value to the number_of_combiners field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_combiners value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_combiners(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_COMBINERS);
}

/**
 * Extract the uint16 value of the base_combiner field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_combiner value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_combiner(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_COMBINER);
}

/**
 * Store a uint16 value to the base_combiner field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_combiner value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_combiner(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_COMBINER);
}

/**
 * Extract the uint16 value of the number_of_demultiplexers field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_demultiplexers value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_demultiplexers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_DEMULTIPLEXERS);
}

/**
 * Store a uint16 value to the number_of_demultiplexers field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_demultiplexers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_demultiplexers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_DEMULTIPLEXERS);
}

/**
 * Extract the uint16 value of the base_demultiplexer field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_demultiplexer value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_demultiplexer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_DEMULTIPLEXER);
}

/**
 * Store a uint16 value to the base_demultiplexer field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_demultiplexer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_demultiplexer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_DEMULTIPLEXER);
}

/**
 * Extract the uint16 value of the number_of_multiplexers field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_multiplexers value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_multiplexers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MULTIPLEXERS);
}

/**
 * Store a uint16 value to the number_of_multiplexers field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_multiplexers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_multiplexers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_MULTIPLEXERS);
}

/**
 * Extract the uint16 value of the base_multiplexer field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_multiplexer value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_multiplexer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MULTIPLEXER);
}

/**
 * Store a uint16 value to the base_multiplexer field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_multiplexer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_multiplexer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_MULTIPLEXER);
}

/**
 * Extract the uint16 value of the number_of_transcoders field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_transcoders value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_transcoders(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_TRANSCODERS);
}

/**
 * Store a uint16 value to the number_of_transcoders field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_transcoders value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_transcoders(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_TRANSCODERS);
}

/**
 * Extract the uint16 value of the base_transcoder field of the DESCRIPTOR_VIDEO
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_transcoder value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_transcoder(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_TRANSCODER);
}

/**
 * Store a uint16 value to the base_transcoder field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_transcoder value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_transcoder(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_TRANSCODER);
}

/**
 * Extract the uint16 value of the number_of_control_blocks field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_control_blocks value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_number_of_control_blocks(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_CONTROL_BLOCKS);
}

/**
 * Store a uint16 value to the number_of_control_blocks field of the
 *DESCRIPTOR_VIDEO object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_control_blocks value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_number_of_control_blocks(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_NUMBER_OF_CONTROL_BLOCKS);
}

/**
 * Extract the uint16 value of the base_control_block field of the
 *DESCRIPTOR_VIDEO object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control_block value
 */
static inline uint16_t jdksavdecc_descriptor_video_get_base_control_block(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_CONTROL_BLOCK);
}

/**
 * Store a uint16 value to the base_control_block field of the DESCRIPTOR_VIDEO
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control_block value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_set_base_control_block(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_OFFSET_BASE_CONTROL_BLOCK);
}

/*@}*/

/** \addtogroup descriptor_video VIDEO_UNIT Descriptor - Clause 7.2.4  */
/*@{*/

/// VIDEO_UNIT Descriptor - Clause 7.2.4
struct jdksavdecc_descriptor_video {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t clock_domain_index;
    uint16_t number_of_stream_input_ports;
    uint16_t base_stream_input_port;
    uint16_t number_of_stream_output_ports;
    uint16_t base_stream_output_port;
    uint16_t number_of_external_input_ports;
    uint16_t base_external_input_port;
    uint16_t number_of_external_output_ports;
    uint16_t base_external_output_port;
    uint16_t number_of_internal_input_ports;
    uint16_t base_internal_input_port;
    uint16_t number_of_internal_output_ports;
    uint16_t base_internal_output_port;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t number_of_signal_selectors;
    uint16_t base_signal_selector;
    uint16_t number_of_mixers;
    uint16_t base_mixer;
    uint16_t number_of_matrices;
    uint16_t base_matrix;
    uint16_t number_of_splitters;
    uint16_t base_splitter;
    uint16_t number_of_combiners;
    uint16_t base_combiner;
    uint16_t number_of_demultiplexers;
    uint16_t base_demultiplexer;
    uint16_t number_of_multiplexers;
    uint16_t base_multiplexer;
    uint16_t number_of_transcoders;
    uint16_t base_transcoder;
    uint16_t number_of_control_blocks;
    uint16_t base_control_block;
};

/**
 * Extract the jdksavdecc_descriptor_video structure from a network buffer.
 *
 *  - Clause 7.2.4
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_video structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_video_read(struct jdksavdecc_descriptor_video *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_VIDEO_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_video_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_video_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_video_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_video_get_localized_description(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_video_get_clock_domain_index(base, pos);
        p->number_of_stream_input_ports = jdksavdecc_descriptor_video_get_number_of_stream_input_ports(base, pos);
        p->base_stream_input_port = jdksavdecc_descriptor_video_get_base_stream_input_port(base, pos);
        p->number_of_stream_output_ports = jdksavdecc_descriptor_video_get_number_of_stream_output_ports(base, pos);
        p->base_stream_output_port = jdksavdecc_descriptor_video_get_base_stream_output_port(base, pos);
        p->number_of_external_input_ports = jdksavdecc_descriptor_video_get_number_of_external_input_ports(base, pos);
        p->base_external_input_port = jdksavdecc_descriptor_video_get_base_external_input_port(base, pos);
        p->number_of_external_output_ports = jdksavdecc_descriptor_video_get_number_of_external_output_ports(base, pos);
        p->base_external_output_port = jdksavdecc_descriptor_video_get_base_external_output_port(base, pos);
        p->number_of_internal_input_ports = jdksavdecc_descriptor_video_get_number_of_internal_input_ports(base, pos);
        p->base_internal_input_port = jdksavdecc_descriptor_video_get_base_internal_input_port(base, pos);
        p->number_of_internal_output_ports = jdksavdecc_descriptor_video_get_number_of_internal_output_ports(base, pos);
        p->base_internal_output_port = jdksavdecc_descriptor_video_get_base_internal_output_port(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_video_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_video_get_base_control(base, pos);
        p->number_of_signal_selectors = jdksavdecc_descriptor_video_get_number_of_signal_selectors(base, pos);
        p->base_signal_selector = jdksavdecc_descriptor_video_get_base_signal_selector(base, pos);
        p->number_of_mixers = jdksavdecc_descriptor_video_get_number_of_mixers(base, pos);
        p->base_mixer = jdksavdecc_descriptor_video_get_base_mixer(base, pos);
        p->number_of_matrices = jdksavdecc_descriptor_video_get_number_of_matrices(base, pos);
        p->base_matrix = jdksavdecc_descriptor_video_get_base_matrix(base, pos);
        p->number_of_splitters = jdksavdecc_descriptor_video_get_number_of_splitters(base, pos);
        p->base_splitter = jdksavdecc_descriptor_video_get_base_splitter(base, pos);
        p->number_of_combiners = jdksavdecc_descriptor_video_get_number_of_combiners(base, pos);
        p->base_combiner = jdksavdecc_descriptor_video_get_base_combiner(base, pos);
        p->number_of_demultiplexers = jdksavdecc_descriptor_video_get_number_of_demultiplexers(base, pos);
        p->base_demultiplexer = jdksavdecc_descriptor_video_get_base_demultiplexer(base, pos);
        p->number_of_multiplexers = jdksavdecc_descriptor_video_get_number_of_multiplexers(base, pos);
        p->base_multiplexer = jdksavdecc_descriptor_video_get_base_multiplexer(base, pos);
        p->number_of_transcoders = jdksavdecc_descriptor_video_get_number_of_transcoders(base, pos);
        p->base_transcoder = jdksavdecc_descriptor_video_get_base_transcoder(base, pos);
        p->number_of_control_blocks = jdksavdecc_descriptor_video_get_number_of_control_blocks(base, pos);
        p->base_control_block = jdksavdecc_descriptor_video_get_base_control_block(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_video structure to a network buffer.
 *
 *  - Clause 7.2.4
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_video structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_video_write(struct jdksavdecc_descriptor_video const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_VIDEO_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_video_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_video_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_video_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_video_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_video_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_video_set_number_of_stream_input_ports(p->number_of_stream_input_ports, base, pos);
        jdksavdecc_descriptor_video_set_base_stream_input_port(p->base_stream_input_port, base, pos);
        jdksavdecc_descriptor_video_set_number_of_stream_output_ports(p->number_of_stream_output_ports, base, pos);
        jdksavdecc_descriptor_video_set_base_stream_output_port(p->base_stream_output_port, base, pos);
        jdksavdecc_descriptor_video_set_number_of_external_input_ports(p->number_of_external_input_ports, base, pos);
        jdksavdecc_descriptor_video_set_base_external_input_port(p->base_external_input_port, base, pos);
        jdksavdecc_descriptor_video_set_number_of_external_output_ports(p->number_of_external_output_ports, base, pos);
        jdksavdecc_descriptor_video_set_base_external_output_port(p->base_external_output_port, base, pos);
        jdksavdecc_descriptor_video_set_number_of_internal_input_ports(p->number_of_internal_input_ports, base, pos);
        jdksavdecc_descriptor_video_set_base_internal_input_port(p->base_internal_input_port, base, pos);
        jdksavdecc_descriptor_video_set_number_of_internal_output_ports(p->number_of_internal_output_ports, base, pos);
        jdksavdecc_descriptor_video_set_base_internal_output_port(p->base_internal_output_port, base, pos);
        jdksavdecc_descriptor_video_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_video_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_video_set_number_of_signal_selectors(p->number_of_signal_selectors, base, pos);
        jdksavdecc_descriptor_video_set_base_signal_selector(p->base_signal_selector, base, pos);
        jdksavdecc_descriptor_video_set_number_of_mixers(p->number_of_mixers, base, pos);
        jdksavdecc_descriptor_video_set_base_mixer(p->base_mixer, base, pos);
        jdksavdecc_descriptor_video_set_number_of_matrices(p->number_of_matrices, base, pos);
        jdksavdecc_descriptor_video_set_base_matrix(p->base_matrix, base, pos);
        jdksavdecc_descriptor_video_set_number_of_splitters(p->number_of_splitters, base, pos);
        jdksavdecc_descriptor_video_set_base_splitter(p->base_splitter, base, pos);
        jdksavdecc_descriptor_video_set_number_of_combiners(p->number_of_combiners, base, pos);
        jdksavdecc_descriptor_video_set_base_combiner(p->base_combiner, base, pos);
        jdksavdecc_descriptor_video_set_number_of_demultiplexers(p->number_of_demultiplexers, base, pos);
        jdksavdecc_descriptor_video_set_base_demultiplexer(p->base_demultiplexer, base, pos);
        jdksavdecc_descriptor_video_set_number_of_multiplexers(p->number_of_multiplexers, base, pos);
        jdksavdecc_descriptor_video_set_base_multiplexer(p->base_multiplexer, base, pos);
        jdksavdecc_descriptor_video_set_number_of_transcoders(p->number_of_transcoders, base, pos);
        jdksavdecc_descriptor_video_set_base_transcoder(p->base_transcoder, base, pos);
        jdksavdecc_descriptor_video_set_number_of_control_blocks(p->number_of_control_blocks, base, pos);
        jdksavdecc_descriptor_video_set_base_control_block(p->base_control_block, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_sensor SENSOR_UNIT Descriptor - Clause 7.2.5  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_SENSOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_sensor_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_SENSOR object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the number_of_stream_input_ports field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_stream_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_stream_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_stream_input_ports field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_stream_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_stream_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_STREAM_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_stream_input_port field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_stream_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_stream_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_STREAM_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_stream_input_port field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_stream_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_stream_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_STREAM_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_stream_output_ports field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_stream_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_stream_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_stream_output_ports field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_stream_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_stream_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_STREAM_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_stream_output_port field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_stream_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_stream_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_STREAM_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_stream_output_port field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_stream_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_stream_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_STREAM_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_external_input_ports field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_external_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_external_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_external_input_ports field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_external_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_external_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_EXTERNAL_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_external_input_port field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_external_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_external_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_EXTERNAL_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_external_input_port field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_external_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_external_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_EXTERNAL_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_external_output_ports field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_external_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_external_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_external_output_ports field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_external_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_external_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_EXTERNAL_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_external_output_port field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_external_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_external_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_EXTERNAL_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_external_output_port field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_external_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_external_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_EXTERNAL_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_internal_input_ports field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_internal_input_ports value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_internal_input_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_internal_input_ports field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_internal_input_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_internal_input_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_INTERNAL_INPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_internal_input_port field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_internal_input_port value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_internal_input_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_INTERNAL_INPUT_PORT);
}

/**
 * Store a uint16 value to the base_internal_input_port field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_internal_input_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_internal_input_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_INTERNAL_INPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_internal_output_ports field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_internal_output_ports value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_internal_output_ports(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS);
}

/**
 * Store a uint16 value to the number_of_internal_output_ports field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_internal_output_ports value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_internal_output_ports(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_INTERNAL_OUTPUT_PORTS);
}

/**
 * Extract the uint16 value of the base_internal_output_port field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_internal_output_port value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_internal_output_port(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_INTERNAL_OUTPUT_PORT);
}

/**
 * Store a uint16 value to the base_internal_output_port field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_internal_output_port value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_internal_output_port(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_INTERNAL_OUTPUT_PORT);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the DESCRIPTOR_SENSOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the number_of_signal_selectors field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_signal_selectors value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_signal_selectors(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_SIGNAL_SELECTORS);
}

/**
 * Store a uint16 value to the number_of_signal_selectors field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_signal_selectors value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_signal_selectors(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_SIGNAL_SELECTORS);
}

/**
 * Extract the uint16 value of the base_signal_selector field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_signal_selector value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_signal_selector(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_SIGNAL_SELECTOR);
}

/**
 * Store a uint16 value to the base_signal_selector field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_signal_selector value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_signal_selector(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_SIGNAL_SELECTOR);
}

/**
 * Extract the uint16 value of the number_of_mixers field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mixers value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_mixers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MIXERS);
}

/**
 * Store a uint16 value to the number_of_mixers field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mixers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_mixers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MIXERS);
}

/**
 * Extract the uint16 value of the base_mixer field of the DESCRIPTOR_SENSOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_mixer value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_mixer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MIXER);
}

/**
 * Store a uint16 value to the base_mixer field of the DESCRIPTOR_SENSOR object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_mixer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_mixer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MIXER);
}

/**
 * Extract the uint16 value of the number_of_matrices field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_matrices value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_matrices(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MATRICES);
}

/**
 * Store a uint16 value to the number_of_matrices field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_matrices value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_matrices(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MATRICES);
}

/**
 * Extract the uint16 value of the base_matrix field of the DESCRIPTOR_SENSOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_matrix value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_matrix(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MATRIX);
}

/**
 * Store a uint16 value to the base_matrix field of the DESCRIPTOR_SENSOR object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_matrix value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_matrix(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MATRIX);
}

/**
 * Extract the uint16 value of the number_of_splitters field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_splitters value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_splitters(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_SPLITTERS);
}

/**
 * Store a uint16 value to the number_of_splitters field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_splitters value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_splitters(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_SPLITTERS);
}

/**
 * Extract the uint16 value of the base_splitter field of the DESCRIPTOR_SENSOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_splitter value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_splitter(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_SPLITTER);
}

/**
 * Store a uint16 value to the base_splitter field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_splitter value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_splitter(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_SPLITTER);
}

/**
 * Extract the uint16 value of the number_of_combiners field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_combiners value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_combiners(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_COMBINERS);
}

/**
 * Store a uint16 value to the number_of_combiners field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_combiners value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_combiners(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_COMBINERS);
}

/**
 * Extract the uint16 value of the base_combiner field of the DESCRIPTOR_SENSOR
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_combiner value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_combiner(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_COMBINER);
}

/**
 * Store a uint16 value to the base_combiner field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_combiner value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_combiner(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_COMBINER);
}

/**
 * Extract the uint16 value of the number_of_demultiplexers field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_demultiplexers value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_demultiplexers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_DEMULTIPLEXERS);
}

/**
 * Store a uint16 value to the number_of_demultiplexers field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_demultiplexers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_demultiplexers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_DEMULTIPLEXERS);
}

/**
 * Extract the uint16 value of the base_demultiplexer field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_demultiplexer value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_demultiplexer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_DEMULTIPLEXER);
}

/**
 * Store a uint16 value to the base_demultiplexer field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_demultiplexer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_demultiplexer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_DEMULTIPLEXER);
}

/**
 * Extract the uint16 value of the number_of_multiplexers field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_multiplexers value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_multiplexers(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MULTIPLEXERS);
}

/**
 * Store a uint16 value to the number_of_multiplexers field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_multiplexers value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_multiplexers(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_MULTIPLEXERS);
}

/**
 * Extract the uint16 value of the base_multiplexer field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_multiplexer value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_multiplexer(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MULTIPLEXER);
}

/**
 * Store a uint16 value to the base_multiplexer field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_multiplexer value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_multiplexer(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_MULTIPLEXER);
}

/**
 * Extract the uint16 value of the number_of_transcoders field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_transcoders value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_transcoders(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_TRANSCODERS);
}

/**
 * Store a uint16 value to the number_of_transcoders field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_transcoders value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_transcoders(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_TRANSCODERS);
}

/**
 * Extract the uint16 value of the base_transcoder field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_transcoder value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_transcoder(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_TRANSCODER);
}

/**
 * Store a uint16 value to the base_transcoder field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_transcoder value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_transcoder(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_TRANSCODER);
}

/**
 * Extract the uint16 value of the number_of_control_blocks field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_control_blocks value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_number_of_control_blocks(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_CONTROL_BLOCKS);
}

/**
 * Store a uint16 value to the number_of_control_blocks field of the
 *DESCRIPTOR_SENSOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_control_blocks value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_number_of_control_blocks(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_NUMBER_OF_CONTROL_BLOCKS);
}

/**
 * Extract the uint16 value of the base_control_block field of the
 *DESCRIPTOR_SENSOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control_block value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_get_base_control_block(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_CONTROL_BLOCK);
}

/**
 * Store a uint16 value to the base_control_block field of the DESCRIPTOR_SENSOR
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control_block value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_set_base_control_block(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_OFFSET_BASE_CONTROL_BLOCK);
}

/*@}*/

/** \addtogroup descriptor_sensor SENSOR_UNIT Descriptor - Clause 7.2.5  */
/*@{*/

/// SENSOR_UNIT Descriptor - Clause 7.2.5
struct jdksavdecc_descriptor_sensor {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t clock_domain_index;
    uint16_t number_of_stream_input_ports;
    uint16_t base_stream_input_port;
    uint16_t number_of_stream_output_ports;
    uint16_t base_stream_output_port;
    uint16_t number_of_external_input_ports;
    uint16_t base_external_input_port;
    uint16_t number_of_external_output_ports;
    uint16_t base_external_output_port;
    uint16_t number_of_internal_input_ports;
    uint16_t base_internal_input_port;
    uint16_t number_of_internal_output_ports;
    uint16_t base_internal_output_port;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t number_of_signal_selectors;
    uint16_t base_signal_selector;
    uint16_t number_of_mixers;
    uint16_t base_mixer;
    uint16_t number_of_matrices;
    uint16_t base_matrix;
    uint16_t number_of_splitters;
    uint16_t base_splitter;
    uint16_t number_of_combiners;
    uint16_t base_combiner;
    uint16_t number_of_demultiplexers;
    uint16_t base_demultiplexer;
    uint16_t number_of_multiplexers;
    uint16_t base_multiplexer;
    uint16_t number_of_transcoders;
    uint16_t base_transcoder;
    uint16_t number_of_control_blocks;
    uint16_t base_control_block;
};

/**
 * Extract the jdksavdecc_descriptor_sensor structure from a network buffer.
 *
 *  - Clause 7.2.5
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_sensor structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_sensor_read(struct jdksavdecc_descriptor_sensor *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SENSOR_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_sensor_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_sensor_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_sensor_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_sensor_get_localized_description(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_sensor_get_clock_domain_index(base, pos);
        p->number_of_stream_input_ports = jdksavdecc_descriptor_sensor_get_number_of_stream_input_ports(base, pos);
        p->base_stream_input_port = jdksavdecc_descriptor_sensor_get_base_stream_input_port(base, pos);
        p->number_of_stream_output_ports = jdksavdecc_descriptor_sensor_get_number_of_stream_output_ports(base, pos);
        p->base_stream_output_port = jdksavdecc_descriptor_sensor_get_base_stream_output_port(base, pos);
        p->number_of_external_input_ports = jdksavdecc_descriptor_sensor_get_number_of_external_input_ports(base, pos);
        p->base_external_input_port = jdksavdecc_descriptor_sensor_get_base_external_input_port(base, pos);
        p->number_of_external_output_ports = jdksavdecc_descriptor_sensor_get_number_of_external_output_ports(base, pos);
        p->base_external_output_port = jdksavdecc_descriptor_sensor_get_base_external_output_port(base, pos);
        p->number_of_internal_input_ports = jdksavdecc_descriptor_sensor_get_number_of_internal_input_ports(base, pos);
        p->base_internal_input_port = jdksavdecc_descriptor_sensor_get_base_internal_input_port(base, pos);
        p->number_of_internal_output_ports = jdksavdecc_descriptor_sensor_get_number_of_internal_output_ports(base, pos);
        p->base_internal_output_port = jdksavdecc_descriptor_sensor_get_base_internal_output_port(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_sensor_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_sensor_get_base_control(base, pos);
        p->number_of_signal_selectors = jdksavdecc_descriptor_sensor_get_number_of_signal_selectors(base, pos);
        p->base_signal_selector = jdksavdecc_descriptor_sensor_get_base_signal_selector(base, pos);
        p->number_of_mixers = jdksavdecc_descriptor_sensor_get_number_of_mixers(base, pos);
        p->base_mixer = jdksavdecc_descriptor_sensor_get_base_mixer(base, pos);
        p->number_of_matrices = jdksavdecc_descriptor_sensor_get_number_of_matrices(base, pos);
        p->base_matrix = jdksavdecc_descriptor_sensor_get_base_matrix(base, pos);
        p->number_of_splitters = jdksavdecc_descriptor_sensor_get_number_of_splitters(base, pos);
        p->base_splitter = jdksavdecc_descriptor_sensor_get_base_splitter(base, pos);
        p->number_of_combiners = jdksavdecc_descriptor_sensor_get_number_of_combiners(base, pos);
        p->base_combiner = jdksavdecc_descriptor_sensor_get_base_combiner(base, pos);
        p->number_of_demultiplexers = jdksavdecc_descriptor_sensor_get_number_of_demultiplexers(base, pos);
        p->base_demultiplexer = jdksavdecc_descriptor_sensor_get_base_demultiplexer(base, pos);
        p->number_of_multiplexers = jdksavdecc_descriptor_sensor_get_number_of_multiplexers(base, pos);
        p->base_multiplexer = jdksavdecc_descriptor_sensor_get_base_multiplexer(base, pos);
        p->number_of_transcoders = jdksavdecc_descriptor_sensor_get_number_of_transcoders(base, pos);
        p->base_transcoder = jdksavdecc_descriptor_sensor_get_base_transcoder(base, pos);
        p->number_of_control_blocks = jdksavdecc_descriptor_sensor_get_number_of_control_blocks(base, pos);
        p->base_control_block = jdksavdecc_descriptor_sensor_get_base_control_block(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_sensor structure to a network buffer.
 *
 *  - Clause 7.2.5
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_sensor structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_sensor_write(struct jdksavdecc_descriptor_sensor const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SENSOR_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_sensor_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_sensor_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_sensor_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_sensor_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_sensor_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_stream_input_ports(p->number_of_stream_input_ports, base, pos);
        jdksavdecc_descriptor_sensor_set_base_stream_input_port(p->base_stream_input_port, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_stream_output_ports(p->number_of_stream_output_ports, base, pos);
        jdksavdecc_descriptor_sensor_set_base_stream_output_port(p->base_stream_output_port, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_external_input_ports(p->number_of_external_input_ports, base, pos);
        jdksavdecc_descriptor_sensor_set_base_external_input_port(p->base_external_input_port, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_external_output_ports(p->number_of_external_output_ports, base, pos);
        jdksavdecc_descriptor_sensor_set_base_external_output_port(p->base_external_output_port, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_internal_input_ports(p->number_of_internal_input_ports, base, pos);
        jdksavdecc_descriptor_sensor_set_base_internal_input_port(p->base_internal_input_port, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_internal_output_ports(p->number_of_internal_output_ports, base, pos);
        jdksavdecc_descriptor_sensor_set_base_internal_output_port(p->base_internal_output_port, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_sensor_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_signal_selectors(p->number_of_signal_selectors, base, pos);
        jdksavdecc_descriptor_sensor_set_base_signal_selector(p->base_signal_selector, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_mixers(p->number_of_mixers, base, pos);
        jdksavdecc_descriptor_sensor_set_base_mixer(p->base_mixer, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_matrices(p->number_of_matrices, base, pos);
        jdksavdecc_descriptor_sensor_set_base_matrix(p->base_matrix, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_splitters(p->number_of_splitters, base, pos);
        jdksavdecc_descriptor_sensor_set_base_splitter(p->base_splitter, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_combiners(p->number_of_combiners, base, pos);
        jdksavdecc_descriptor_sensor_set_base_combiner(p->base_combiner, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_demultiplexers(p->number_of_demultiplexers, base, pos);
        jdksavdecc_descriptor_sensor_set_base_demultiplexer(p->base_demultiplexer, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_multiplexers(p->number_of_multiplexers, base, pos);
        jdksavdecc_descriptor_sensor_set_base_multiplexer(p->base_multiplexer, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_transcoders(p->number_of_transcoders, base, pos);
        jdksavdecc_descriptor_sensor_set_base_transcoder(p->base_transcoder, base, pos);
        jdksavdecc_descriptor_sensor_set_number_of_control_blocks(p->number_of_control_blocks, base, pos);
        jdksavdecc_descriptor_sensor_set_base_control_block(p->base_control_block, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_stream STREAM_INPUT and STREAM_OUTPUT Descriptor -
 * Clause 7.2.6  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_STREAM
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_stream_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_STREAM object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the stream_flags field of the DESCRIPTOR_STREAM
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t stream_flags value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_stream_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_STREAM_FLAGS);
}

/**
 * Store a uint16 value to the stream_flags field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t stream_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_stream_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_STREAM_FLAGS);
}

/**
 * Extract the eui64 value of the current_format field of the DESCRIPTOR_STREAM
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 current_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_stream_get_current_format(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_CURRENT_FORMAT);
}

/**
 * Store a eui64 value to the current_format field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 current_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_current_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_CURRENT_FORMAT);
}

/**
 * Extract the uint16 value of the formats_offset field of the DESCRIPTOR_STREAM
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t formats_offset value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_formats_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_FORMATS_OFFSET);
}

/**
 * Store a uint16 value to the formats_offset field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t formats_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_formats_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_FORMATS_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_formats field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_formats value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_number_of_formats(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_NUMBER_OF_FORMATS);
}

/**
 * Store a uint16 value to the number_of_formats field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_formats value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_number_of_formats(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_NUMBER_OF_FORMATS);
}

/**
 * Extract the eui64 value of the backup_talker_entity_id_0 field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 backup_talker_entity_id_0 value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_stream_get_backup_talker_entity_id_0(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_0);
}

/**
 * Store a eui64 value to the backup_talker_entity_id_0 field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 backup_talker_entity_id_0 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_stream_set_backup_talker_entity_id_0(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_0);
}

/**
 * Extract the uint16 value of the backup_talker_unique_0 field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t backup_talker_unique_0 value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_backup_talker_unique_0(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_0);
}

/**
 * Store a uint16 value to the backup_talker_unique_0 field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t backup_talker_unique_0 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_backup_talker_unique_0(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_0);
}

/**
 * Extract the eui64 value of the backup_talker_entity_id_1 field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 backup_talker_entity_id_1 value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_stream_get_backup_talker_entity_id_1(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_1);
}

/**
 * Store a eui64 value to the backup_talker_entity_id_1 field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 backup_talker_entity_id_1 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_stream_set_backup_talker_entity_id_1(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_1);
}

/**
 * Extract the uint16 value of the backup_talker_unique_1 field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t backup_talker_unique_1 value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_backup_talker_unique_1(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_1);
}

/**
 * Store a uint16 value to the backup_talker_unique_1 field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t backup_talker_unique_1 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_backup_talker_unique_1(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_1);
}

/**
 * Extract the eui64 value of the backup_talker_entity_id_2 field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 backup_talker_entity_id_2 value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_stream_get_backup_talker_entity_id_2(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_2);
}

/**
 * Store a eui64 value to the backup_talker_entity_id_2 field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 backup_talker_entity_id_2 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_stream_set_backup_talker_entity_id_2(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_ENTITY_ID_2);
}

/**
 * Extract the uint16 value of the backup_talker_unique_2 field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t backup_talker_unique_2 value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_backup_talker_unique_2(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_2);
}

/**
 * Store a uint16 value to the backup_talker_unique_2 field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t backup_talker_unique_2 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_backup_talker_unique_2(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKUP_TALKER_UNIQUE_2);
}

/**
 * Extract the eui64 value of the backedup_talker_entity_id field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 backedup_talker_entity_id value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_stream_get_backedup_talker_entity_id(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKEDUP_TALKER_ENTITY_ID);
}

/**
 * Store a eui64 value to the backedup_talker_entity_id field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 backedup_talker_entity_id value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_stream_set_backedup_talker_entity_id(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKEDUP_TALKER_ENTITY_ID);
}

/**
 * Extract the uint16 value of the backedup_talker_unique field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t backedup_talker_unique value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_backedup_talker_unique(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKEDUP_TALKER_UNIQUE);
}

/**
 * Store a uint16 value to the backedup_talker_unique field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t backedup_talker_unique value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_backedup_talker_unique(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BACKEDUP_TALKER_UNIQUE);
}

/**
 * Extract the uint16 value of the avb_interface_index field of the
 *DESCRIPTOR_STREAM object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t avb_interface_index value
 */
static inline uint16_t jdksavdecc_descriptor_stream_get_avb_interface_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_AVB_INTERFACE_INDEX);
}

/**
 * Store a uint16 value to the avb_interface_index field of the
 *DESCRIPTOR_STREAM object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t avb_interface_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_avb_interface_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_AVB_INTERFACE_INDEX);
}

/**
 * Extract the uint32 value of the buffer_length field of the DESCRIPTOR_STREAM
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t buffer_length value
 */
static inline uint32_t jdksavdecc_descriptor_stream_get_buffer_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BUFFER_LENGTH);
}

/**
 * Store a uint32 value to the buffer_length field of the DESCRIPTOR_STREAM
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t buffer_length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_set_buffer_length(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_OFFSET_BUFFER_LENGTH);
}

/*@}*/

/** \addtogroup descriptor_stream STREAM_INPUT and STREAM_OUTPUT Descriptor -
 * Clause 7.2.6  */
/*@{*/

/// STREAM_INPUT and STREAM_OUTPUT Descriptor - Clause 7.2.6
struct jdksavdecc_descriptor_stream {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t clock_domain_index;
    uint16_t stream_flags;
    struct jdksavdecc_eui64 current_format;
    uint16_t formats_offset;
    uint16_t number_of_formats;
    struct jdksavdecc_eui64 backup_talker_entity_id_0;
    uint16_t backup_talker_unique_0;
    struct jdksavdecc_eui64 backup_talker_entity_id_1;
    uint16_t backup_talker_unique_1;
    struct jdksavdecc_eui64 backup_talker_entity_id_2;
    uint16_t backup_talker_unique_2;
    struct jdksavdecc_eui64 backedup_talker_entity_id;
    uint16_t backedup_talker_unique;
    uint16_t avb_interface_index;
    uint32_t buffer_length;
};

/**
 * Extract the jdksavdecc_descriptor_stream structure from a network buffer.
 *
 *  - Clause 7.2.6
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_stream structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_stream_read(struct jdksavdecc_descriptor_stream *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_STREAM_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_stream_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_stream_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_stream_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_stream_get_localized_description(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_stream_get_clock_domain_index(base, pos);
        p->stream_flags = jdksavdecc_descriptor_stream_get_stream_flags(base, pos);
        p->current_format = jdksavdecc_descriptor_stream_get_current_format(base, pos);
        p->formats_offset = jdksavdecc_descriptor_stream_get_formats_offset(base, pos);
        p->number_of_formats = jdksavdecc_descriptor_stream_get_number_of_formats(base, pos);
        p->backup_talker_entity_id_0 = jdksavdecc_descriptor_stream_get_backup_talker_entity_id_0(base, pos);
        p->backup_talker_unique_0 = jdksavdecc_descriptor_stream_get_backup_talker_unique_0(base, pos);
        p->backup_talker_entity_id_1 = jdksavdecc_descriptor_stream_get_backup_talker_entity_id_1(base, pos);
        p->backup_talker_unique_1 = jdksavdecc_descriptor_stream_get_backup_talker_unique_1(base, pos);
        p->backup_talker_entity_id_2 = jdksavdecc_descriptor_stream_get_backup_talker_entity_id_2(base, pos);
        p->backup_talker_unique_2 = jdksavdecc_descriptor_stream_get_backup_talker_unique_2(base, pos);
        p->backedup_talker_entity_id = jdksavdecc_descriptor_stream_get_backedup_talker_entity_id(base, pos);
        p->backedup_talker_unique = jdksavdecc_descriptor_stream_get_backedup_talker_unique(base, pos);
        p->avb_interface_index = jdksavdecc_descriptor_stream_get_avb_interface_index(base, pos);
        p->buffer_length = jdksavdecc_descriptor_stream_get_buffer_length(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_stream structure to a network buffer.
 *
 *  - Clause 7.2.6
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_stream structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_stream_write(struct jdksavdecc_descriptor_stream const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_STREAM_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_stream_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_stream_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_stream_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_stream_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_stream_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_stream_set_stream_flags(p->stream_flags, base, pos);
        jdksavdecc_descriptor_stream_set_current_format(p->current_format, base, pos);
        jdksavdecc_descriptor_stream_set_formats_offset(p->formats_offset, base, pos);
        jdksavdecc_descriptor_stream_set_number_of_formats(p->number_of_formats, base, pos);
        jdksavdecc_descriptor_stream_set_backup_talker_entity_id_0(p->backup_talker_entity_id_0, base, pos);
        jdksavdecc_descriptor_stream_set_backup_talker_unique_0(p->backup_talker_unique_0, base, pos);
        jdksavdecc_descriptor_stream_set_backup_talker_entity_id_1(p->backup_talker_entity_id_1, base, pos);
        jdksavdecc_descriptor_stream_set_backup_talker_unique_1(p->backup_talker_unique_1, base, pos);
        jdksavdecc_descriptor_stream_set_backup_talker_entity_id_2(p->backup_talker_entity_id_2, base, pos);
        jdksavdecc_descriptor_stream_set_backup_talker_unique_2(p->backup_talker_unique_2, base, pos);
        jdksavdecc_descriptor_stream_set_backedup_talker_entity_id(p->backedup_talker_entity_id, base, pos);
        jdksavdecc_descriptor_stream_set_backedup_talker_unique(p->backedup_talker_unique, base, pos);
        jdksavdecc_descriptor_stream_set_avb_interface_index(p->avb_interface_index, base, pos);
        jdksavdecc_descriptor_stream_set_buffer_length(p->buffer_length, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_jack JACK_INPUT and JACK_OUTPUT Descriptor - Clause
 * 7.2.7  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the DESCRIPTOR_JACK
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_JACK
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the DESCRIPTOR_JACK
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_JACK
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_JACK
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_jack_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_JACK object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_JACK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_JACK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the jack_flags field of the DESCRIPTOR_JACK
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t jack_flags value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_jack_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_JACK_FLAGS);
}

/**
 * Store a uint16 value to the jack_flags field of the DESCRIPTOR_JACK object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t jack_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_jack_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_JACK_FLAGS);
}

/**
 * Extract the uint16 value of the jack_type field of the DESCRIPTOR_JACK object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t jack_type value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_jack_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_JACK_TYPE);
}

/**
 * Store a uint16 value to the jack_type field of the DESCRIPTOR_JACK object to
 *a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t jack_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_jack_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_JACK_TYPE);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_JACK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the DESCRIPTOR_JACK
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the DESCRIPTOR_JACK
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_jack_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the DESCRIPTOR_JACK object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_jack_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_JACK_OFFSET_BASE_CONTROL);
}

/*@}*/

/** \addtogroup descriptor_jack JACK_INPUT and JACK_OUTPUT Descriptor - Clause
 * 7.2.7  */
/*@{*/

/// JACK_INPUT and JACK_OUTPUT Descriptor - Clause 7.2.7
struct jdksavdecc_descriptor_jack {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t jack_flags;
    uint16_t jack_type;
    uint16_t number_of_controls;
    uint16_t base_control;
};

/**
 * Extract the jdksavdecc_descriptor_jack structure from a network buffer.
 *
 *  - Clause 7.2.7
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_jack structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_jack_read(struct jdksavdecc_descriptor_jack *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_JACK_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_jack_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_jack_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_jack_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_jack_get_localized_description(base, pos);
        p->jack_flags = jdksavdecc_descriptor_jack_get_jack_flags(base, pos);
        p->jack_type = jdksavdecc_descriptor_jack_get_jack_type(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_jack_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_jack_get_base_control(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_jack structure to a network buffer.
 *
 *  - Clause 7.2.7
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_jack structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_jack_write(struct jdksavdecc_descriptor_jack const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_JACK_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_jack_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_jack_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_jack_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_jack_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_jack_set_jack_flags(p->jack_flags, base, pos);
        jdksavdecc_descriptor_jack_set_jack_type(p->jack_type, base, pos);
        jdksavdecc_descriptor_jack_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_jack_set_base_control(p->base_control, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_avb_interface AVB_INTERFACE Descriptor - Clause 7.2.8
 */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_avb_interface_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_avb_interface_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_avb_interface_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_AVB_INTERFACE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_avb_interface_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the eui48 value of the mac_address field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui48 mac_address value
 */
static inline struct jdksavdecc_eui48 jdksavdecc_descriptor_avb_interface_get_mac_address(void const *base, ssize_t pos) {
    return jdksavdecc_eui48_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_MAC_ADDRESS);
}

/**
 * Store a eui48 value to the mac_address field of the DESCRIPTOR_AVB_INTERFACE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui48 mac_address value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_mac_address(struct jdksavdecc_eui48 v, void *base, ssize_t pos) {
    jdksavdecc_eui48_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_MAC_ADDRESS);
}

/**
 * Extract the uint16 value of the interface_flags field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t interface_flags value
 */
static inline uint16_t jdksavdecc_descriptor_avb_interface_get_interface_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_INTERFACE_FLAGS);
}

/**
 * Store a uint16 value to the interface_flags field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t interface_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_interface_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_INTERFACE_FLAGS);
}

/**
 * Extract the eui64 value of the clock_identity field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 clock_identity value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_avb_interface_get_clock_identity(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_IDENTITY);
}

/**
 * Store a eui64 value to the clock_identity field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 clock_identity value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_clock_identity(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_IDENTITY);
}

/**
 * Extract the uint8 value of the priority1 field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t priority1 value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_priority1(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PRIORITY1);
}

/**
 * Store a uint8 value to the priority1 field of the DESCRIPTOR_AVB_INTERFACE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t priority1 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_priority1(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PRIORITY1);
}

/**
 * Extract the uint8 value of the clock_class field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t clock_class value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_clock_class(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_CLASS);
}

/**
 * Store a uint8 value to the clock_class field of the DESCRIPTOR_AVB_INTERFACE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t clock_class value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_clock_class(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_CLASS);
}

/**
 * Extract the uint16 value of the offset_scaled_log_variance field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t offset_scaled_log_variance value
 */
static inline uint16_t jdksavdecc_descriptor_avb_interface_get_offset_scaled_log_variance(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_OFFSET_SCALED_LOG_VARIANCE);
}

/**
 * Store a uint16 value to the offset_scaled_log_variance field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t offset_scaled_log_variance value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_offset_scaled_log_variance(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_OFFSET_SCALED_LOG_VARIANCE);
}

/**
 * Extract the uint8 value of the clock_accuracy field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t clock_accuracy value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_clock_accuracy(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_ACCURACY);
}

/**
 * Store a uint8 value to the clock_accuracy field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t clock_accuracy value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_clock_accuracy(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_CLOCK_ACCURACY);
}

/**
 * Extract the uint8 value of the priority2 field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t priority2 value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_priority2(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PRIORITY2);
}

/**
 * Store a uint8 value to the priority2 field of the DESCRIPTOR_AVB_INTERFACE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t priority2 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_priority2(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PRIORITY2);
}

/**
 * Extract the uint8 value of the domain_number field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t domain_number value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_domain_number(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DOMAIN_NUMBER);
}

/**
 * Store a uint8 value to the domain_number field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t domain_number value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_domain_number(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_DOMAIN_NUMBER);
}

/**
 * Extract the uint8 value of the log_sync_interval field of the
 *DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t log_sync_interval value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_log_sync_interval(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_SYNC_INTERVAL);
}

/**
 * Store a uint8 value to the log_sync_interval field of the
 *DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t log_sync_interval value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_log_sync_interval(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_SYNC_INTERVAL);
}

/**
 * Extract the uint8 value of the log_announce_interval field of the DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t log_announce_interval value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_log_announce_interval(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_ANNOUNCE_INTERVAL);
}

/**
 * Store a uint8 value to the log_announce_interval field of the DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t log_announce_interval value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_log_announce_interval(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_ANNOUNCE_INTERVAL);
}

/**
 * Extract the uint8 value of the log_pdelay_interval field of the DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t log_pdelay_interval value
 */
static inline uint8_t jdksavdecc_descriptor_avb_interface_get_log_pdelay_interval(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_PDELAY_INTERVAL);
}

/**
 * Store a uint8 value to the log_pdelay_interval field of the DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t log_pdelay_interval value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_log_pdelay_interval(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_LOG_PDELAY_INTERVAL);
}

/**
 * Extract the uint16 value of the port_number field of the DESCRIPTOR_AVB_INTERFACE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t port_number value
 */
static inline uint16_t jdksavdecc_descriptor_avb_interface_get_port_number(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PORT_NUMBER);
}

/**
 * Store a uint16 value to the port_number field of the DESCRIPTOR_AVB_INTERFACE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t port_number value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_avb_interface_set_port_number(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_OFFSET_PORT_NUMBER);
}

/*@}*/

/** \addtogroup descriptor_avb_interface AVB_INTERFACE Descriptor - Clause 7.2.8
 */
/*@{*/

/// AVB_INTERFACE Descriptor - Clause 7.2.8
struct jdksavdecc_descriptor_avb_interface {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    struct jdksavdecc_eui48 mac_address;
    uint16_t interface_flags;
    struct jdksavdecc_eui64 clock_identity;
    uint8_t priority1;
    uint8_t clock_class;
    uint16_t offset_scaled_log_variance;
    uint8_t clock_accuracy;
    uint8_t priority2;
    uint8_t domain_number;
    int8_t log_sync_interval;
    int8_t log_announce_interval;
    int8_t log_pdelay_interval;
    uint16_t port_number;
};

/**
 * Extract the jdksavdecc_descriptor_avb_interface structure from a network
 *buffer.
 *
 *  - Clause 7.2.8
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_avb_interface structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_avb_interface_read(struct jdksavdecc_descriptor_avb_interface *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_avb_interface_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_avb_interface_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_avb_interface_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_avb_interface_get_localized_description(base, pos);
        p->mac_address = jdksavdecc_descriptor_avb_interface_get_mac_address(base, pos);
        p->interface_flags = jdksavdecc_descriptor_avb_interface_get_interface_flags(base, pos);
        p->clock_identity = jdksavdecc_descriptor_avb_interface_get_clock_identity(base, pos);
        p->priority1 = jdksavdecc_descriptor_avb_interface_get_priority1(base, pos);
        p->clock_class = jdksavdecc_descriptor_avb_interface_get_clock_class(base, pos);
        p->offset_scaled_log_variance = jdksavdecc_descriptor_avb_interface_get_offset_scaled_log_variance(base, pos);
        p->clock_accuracy = jdksavdecc_descriptor_avb_interface_get_clock_accuracy(base, pos);
        p->priority2 = jdksavdecc_descriptor_avb_interface_get_priority2(base, pos);
        p->domain_number = jdksavdecc_descriptor_avb_interface_get_domain_number(base, pos);
        p->log_sync_interval = jdksavdecc_descriptor_avb_interface_get_log_sync_interval(base, pos);
        p->log_announce_interval = jdksavdecc_descriptor_avb_interface_get_log_announce_interval(base, pos);
        p->log_pdelay_interval = jdksavdecc_descriptor_avb_interface_get_log_pdelay_interval(base, pos);
        p->port_number = jdksavdecc_descriptor_avb_interface_get_port_number(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_avb_interface structure to a network buffer.
 *
 *  - Clause 7.2.8
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_avb_interface structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_avb_interface_write(struct jdksavdecc_descriptor_avb_interface const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AVB_INTERFACE_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_avb_interface_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_avb_interface_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_avb_interface_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_avb_interface_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_avb_interface_set_mac_address(p->mac_address, base, pos);
        jdksavdecc_descriptor_avb_interface_set_interface_flags(p->interface_flags, base, pos);
        jdksavdecc_descriptor_avb_interface_set_clock_identity(p->clock_identity, base, pos);
        jdksavdecc_descriptor_avb_interface_set_priority1(p->priority1, base, pos);
        jdksavdecc_descriptor_avb_interface_set_clock_class(p->clock_class, base, pos);
        jdksavdecc_descriptor_avb_interface_set_offset_scaled_log_variance(p->offset_scaled_log_variance, base, pos);
        jdksavdecc_descriptor_avb_interface_set_clock_accuracy(p->clock_accuracy, base, pos);
        jdksavdecc_descriptor_avb_interface_set_priority2(p->priority2, base, pos);
        jdksavdecc_descriptor_avb_interface_set_domain_number(p->domain_number, base, pos);
        jdksavdecc_descriptor_avb_interface_set_log_sync_interval(p->log_sync_interval, base, pos);
        jdksavdecc_descriptor_avb_interface_set_log_announce_interval(p->log_announce_interval, base, pos);
        jdksavdecc_descriptor_avb_interface_set_log_pdelay_interval(p->log_pdelay_interval, base, pos);
        jdksavdecc_descriptor_avb_interface_set_port_number(p->port_number, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_clock_source CLOCK_SOURCE Descriptor - Clause 7.2.9
 */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_clock_source_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_CLOCK_SOURCE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the clock_source_flags field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_flags value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_clock_source_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_FLAGS);
}

/**
 * Store a uint16 value to the clock_source_flags field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_clock_source_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_FLAGS);
}

/**
 * Extract the uint16 value of the clock_source_type field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_type value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_clock_source_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_TYPE);
}

/**
 * Store a uint16 value to the clock_source_type field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_clock_source_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_TYPE);
}

/**
 * Extract the eui64 value of the clock_source_identifier field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 clock_source_identifier value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_clock_source_get_clock_source_identifier(void const *base,
                                                                                                     ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_IDENTIFIER);
}

/**
 * Store a eui64 value to the clock_source_identifier field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 clock_source_identifier value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_clock_source_set_clock_source_identifier(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_IDENTIFIER);
}

/**
 * Extract the uint16 value of the clock_source_location_type field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_location_type value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_clock_source_location_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_LOCATION_TYPE);
}

/**
 * Store a uint16 value to the clock_source_location_type field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_location_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_clock_source_location_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_LOCATION_TYPE);
}

/**
 * Extract the uint16 value of the clock_source_location_index field of the
 *DESCRIPTOR_CLOCK_SOURCE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_location_index value
 */
static inline uint16_t jdksavdecc_descriptor_clock_source_get_clock_source_location_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_LOCATION_INDEX);
}

/**
 * Store a uint16 value to the clock_source_location_index field of the
 *DESCRIPTOR_CLOCK_SOURCE object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_location_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_source_set_clock_source_location_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_OFFSET_CLOCK_SOURCE_LOCATION_INDEX);
}

/*@}*/

/** \addtogroup descriptor_clock_source CLOCK_SOURCE Descriptor - Clause 7.2.9
 */
/*@{*/

/// CLOCK_SOURCE Descriptor - Clause 7.2.9
struct jdksavdecc_descriptor_clock_source {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t clock_source_flags;
    uint16_t clock_source_type;
    struct jdksavdecc_eui64 clock_source_identifier;
    uint16_t clock_source_location_type;
    uint16_t clock_source_location_index;
};

/**
 * Extract the jdksavdecc_descriptor_clock_source structure from a network
 *buffer.
 *
 *  - Clause 7.2.9
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_clock_source structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_clock_source_read(struct jdksavdecc_descriptor_clock_source *p,
                                                              void const *base,
                                                              ssize_t pos,
                                                              size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_clock_source_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_clock_source_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_clock_source_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_clock_source_get_localized_description(base, pos);
        p->clock_source_flags = jdksavdecc_descriptor_clock_source_get_clock_source_flags(base, pos);
        p->clock_source_type = jdksavdecc_descriptor_clock_source_get_clock_source_type(base, pos);
        p->clock_source_identifier = jdksavdecc_descriptor_clock_source_get_clock_source_identifier(base, pos);
        p->clock_source_location_type = jdksavdecc_descriptor_clock_source_get_clock_source_location_type(base, pos);
        p->clock_source_location_index = jdksavdecc_descriptor_clock_source_get_clock_source_location_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_clock_source structure to a network buffer.
 *
 *  - Clause 7.2.9
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_clock_source structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_clock_source_write(struct jdksavdecc_descriptor_clock_source const *p,
                                                               void *base,
                                                               size_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CLOCK_SOURCE_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_clock_source_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_clock_source_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_clock_source_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_clock_source_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_clock_source_set_clock_source_flags(p->clock_source_flags, base, pos);
        jdksavdecc_descriptor_clock_source_set_clock_source_type(p->clock_source_type, base, pos);
        jdksavdecc_descriptor_clock_source_set_clock_source_identifier(p->clock_source_identifier, base, pos);
        jdksavdecc_descriptor_clock_source_set_clock_source_location_type(p->clock_source_location_type, base, pos);
        jdksavdecc_descriptor_clock_source_set_clock_source_location_index(p->clock_source_location_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_memory_object MEMORY_OBJECT Descriptor - Clause
 * 7.2.10  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_memory_object_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_memory_object_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_memory_object_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_MEMORY_OBJECT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_memory_object_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the memory_object_type field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t memory_object_type value
 */
static inline uint16_t jdksavdecc_descriptor_memory_object_get_memory_object_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_MEMORY_OBJECT_TYPE);
}

/**
 * Store a uint16 value to the memory_object_type field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t memory_object_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_memory_object_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_MEMORY_OBJECT_TYPE);
}

/**
 * Extract the uint16 value of the target_descriptor_type field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t target_descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_memory_object_get_target_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_TARGET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the target_descriptor_type field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t target_descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_target_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_TARGET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the target_descriptor_index field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t target_descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_memory_object_get_target_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_TARGET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the target_descriptor_index field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t target_descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_target_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_TARGET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint64_t value of the start_address field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint64_t start_address value
 */
static inline uint64_t jdksavdecc_descriptor_memory_object_get_start_address(void const *base, ssize_t pos) {
    return jdksavdecc_uint64_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_START_ADDRESS);
}

/**
 * Store a uint64_t value to the start_address field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint64_t start_address value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_start_address(uint64_t v, void *base, ssize_t pos) {
    jdksavdecc_uint64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_START_ADDRESS);
}

/**
 * Extract the eui64 value of the maximum_length field of the
 *DESCRIPTOR_MEMORY_OBJECT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint64_t maximum length value
 */
static inline uint64_t jdksavdecc_descriptor_memory_object_get_maximum_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint64_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_MAXIMUM_LENGTH);
}

/**
 * Store a eui64 value to the maximum_length field of the
 *DESCRIPTOR_MEMORY_OBJECT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint64_t length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_maximum_length(uint64_t v, void *base, ssize_t pos) {
    jdksavdecc_uint64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_MAXIMUM_LENGTH);
}

/**
 * Extract the eui64 value of the length field of the DESCRIPTOR_MEMORY_OBJECT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint64_t length value
 */
static inline uint64_t jdksavdecc_descriptor_memory_object_get_length(void const *base, ssize_t pos) {
    return jdksavdecc_uint64_get(base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_LENGTH);
}

/**
 * Store a eui64 value to the length field of the DESCRIPTOR_MEMORY_OBJECT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint64_t length value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_memory_object_set_length(uint64_t v, void *base, ssize_t pos) {
    jdksavdecc_uint64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_OFFSET_LENGTH);
}

/*@}*/

/** \addtogroup descriptor_memory_object MEMORY_OBJECT Descriptor - Clause
 * 7.2.10  */
/*@{*/

/// MEMORY_OBJECT Descriptor - Clause 7.2.10
struct jdksavdecc_descriptor_memory_object {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t memory_object_type;
    uint16_t target_descriptor_type;
    uint16_t target_descriptor_index;
    uint64_t start_address;
    uint64_t maximum_length;
    uint64_t length;
};

/**
 * Extract the jdksavdecc_descriptor_memory_object structure from a network
 *buffer.
 *
 *  - Clause 7.2.10
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_memory_object structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_memory_object_read(struct jdksavdecc_descriptor_memory_object *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_memory_object_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_memory_object_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_memory_object_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_memory_object_get_localized_description(base, pos);
        p->memory_object_type = jdksavdecc_descriptor_memory_object_get_memory_object_type(base, pos);
        p->target_descriptor_type = jdksavdecc_descriptor_memory_object_get_target_descriptor_type(base, pos);
        p->target_descriptor_index = jdksavdecc_descriptor_memory_object_get_target_descriptor_index(base, pos);
        p->start_address = jdksavdecc_descriptor_memory_object_get_start_address(base, pos);
        p->maximum_length = jdksavdecc_descriptor_memory_object_get_maximum_length(base, pos);
        p->length = jdksavdecc_descriptor_memory_object_get_length(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_memory_object structure to a network buffer.
 *
 *  - Clause 7.2.10
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_memory_object structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_memory_object_write(struct jdksavdecc_descriptor_memory_object const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MEMORY_OBJECT_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_memory_object_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_memory_object_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_memory_object_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_memory_object_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_memory_object_set_memory_object_type(p->memory_object_type, base, pos);
        jdksavdecc_descriptor_memory_object_set_target_descriptor_type(p->target_descriptor_type, base, pos);
        jdksavdecc_descriptor_memory_object_set_target_descriptor_index(p->target_descriptor_index, base, pos);
        jdksavdecc_descriptor_memory_object_set_start_address(p->start_address, base, pos);
        jdksavdecc_descriptor_memory_object_set_maximum_length(p->maximum_length, base, pos);
        jdksavdecc_descriptor_memory_object_set_length(p->length, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_locale LOCALE Descriptor - Clause 7.2.11  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_LOCALE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_locale_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_LOCALE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_locale_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_LOCALE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_locale_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_LOCALE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_locale_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the locale_identifier field of the
 *DESCRIPTOR_LOCALE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t locale_identifier value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_locale_get_locale_identifier(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_LOCALE_IDENTIFIER);
}

/**
 * Store a string value to the locale_identifier field of the DESCRIPTOR_LOCALE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t locale_identifier value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_locale_set_locale_identifier(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_LOCALE_IDENTIFIER);
}

/**
 * Extract the uint16 value of the number_of_strings field of the
 *DESCRIPTOR_LOCALE object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_strings value
 */
static inline uint16_t jdksavdecc_descriptor_locale_get_number_of_strings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_NUMBER_OF_STRINGS);
}

/**
 * Store a uint16 value to the number_of_strings field of the DESCRIPTOR_LOCALE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_strings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_locale_set_number_of_strings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_NUMBER_OF_STRINGS);
}

/**
 * Extract the uint16 value of the base_strings field of the DESCRIPTOR_LOCALE
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_strings value
 */
static inline uint16_t jdksavdecc_descriptor_locale_get_base_strings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_BASE_STRINGS);
}

/**
 * Store a uint16 value to the base_strings field of the DESCRIPTOR_LOCALE
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_strings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_locale_set_base_strings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_LOCALE_OFFSET_BASE_STRINGS);
}

/*@}*/

/** \addtogroup descriptor_locale LOCALE Descriptor - Clause 7.2.11  */
/*@{*/

/// LOCALE Descriptor - Clause 7.2.11
struct jdksavdecc_descriptor_locale {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string locale_identifier;
    uint16_t number_of_strings;
    uint16_t base_strings;
};

/**
 * Extract the jdksavdecc_descriptor_locale structure from a network buffer.
 *
 *  - Clause 7.2.11
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_locale structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_locale_read(struct jdksavdecc_descriptor_locale *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_LOCALE_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_locale_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_locale_get_descriptor_index(base, pos);
        p->locale_identifier = jdksavdecc_descriptor_locale_get_locale_identifier(base, pos);
        p->number_of_strings = jdksavdecc_descriptor_locale_get_number_of_strings(base, pos);
        p->base_strings = jdksavdecc_descriptor_locale_get_base_strings(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_locale structure to a network buffer.
 *
 *  - Clause 7.2.11
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_locale structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_locale_write(struct jdksavdecc_descriptor_locale const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_LOCALE_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_locale_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_locale_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_locale_set_locale_identifier(p->locale_identifier, base, pos);
        jdksavdecc_descriptor_locale_set_number_of_strings(p->number_of_strings, base, pos);
        jdksavdecc_descriptor_locale_set_base_strings(p->base_strings, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_strings STRINGS Descriptor - Clause 7.2.12  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_STRINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_strings_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_STRINGS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_STRINGS object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_strings_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_STRINGS
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the string_0 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_0 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_0(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_0);
}

/**
 * Store a string value to the string_0 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_0 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_0(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_0);
}

/**
 * Extract the string value of the string_1 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_1 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_1(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_1);
}

/**
 * Store a string value to the string_1 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_1 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_1(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_1);
}

/**
 * Extract the string value of the string_2 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_2 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_2(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_2);
}

/**
 * Store a string value to the string_2 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_2 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_2(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_2);
}

/**
 * Extract the string value of the string_3 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_3 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_3(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_3);
}

/**
 * Store a string value to the string_3 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_3 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_3(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_3);
}

/**
 * Extract the string value of the string_4 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_4 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_4(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_4);
}

/**
 * Store a string value to the string_4 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_4 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_4(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_4);
}

/**
 * Extract the string value of the string_5 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_5 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_5(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_5);
}

/**
 * Store a string value to the string_5 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_5 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_5(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_5);
}

/**
 * Extract the string value of the string_6 field of the DESCRIPTOR_STRINGS
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t string_6 value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_strings_get_string_6(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_6);
}

/**
 * Store a string value to the string_6 field of the DESCRIPTOR_STRINGS object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t string_6 value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_strings_set_string_6(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STRINGS_OFFSET_STRING_6);
}

/*@}*/

/** \addtogroup descriptor_strings STRINGS Descriptor - Clause 7.2.12  */
/*@{*/

/// STRINGS Descriptor - Clause 7.2.12
struct jdksavdecc_descriptor_strings {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string string_0;
    struct jdksavdecc_string string_1;
    struct jdksavdecc_string string_2;
    struct jdksavdecc_string string_3;
    struct jdksavdecc_string string_4;
    struct jdksavdecc_string string_5;
    struct jdksavdecc_string string_6;
};

/**
 * Extract the jdksavdecc_descriptor_strings structure from a network buffer.
 *
 *  - Clause 7.2.12
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_strings structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_strings_read(struct jdksavdecc_descriptor_strings *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_STRINGS_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_strings_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_strings_get_descriptor_index(base, pos);
        p->string_0 = jdksavdecc_descriptor_strings_get_string_0(base, pos);
        p->string_1 = jdksavdecc_descriptor_strings_get_string_1(base, pos);
        p->string_2 = jdksavdecc_descriptor_strings_get_string_2(base, pos);
        p->string_3 = jdksavdecc_descriptor_strings_get_string_3(base, pos);
        p->string_4 = jdksavdecc_descriptor_strings_get_string_4(base, pos);
        p->string_5 = jdksavdecc_descriptor_strings_get_string_5(base, pos);
        p->string_6 = jdksavdecc_descriptor_strings_get_string_6(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_strings structure to a network buffer.
 *
 *  - Clause 7.2.12
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_strings structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_strings_write(struct jdksavdecc_descriptor_strings const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_STRINGS_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_strings_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_strings_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_strings_set_string_0(p->string_0, base, pos);
        jdksavdecc_descriptor_strings_set_string_1(p->string_1, base, pos);
        jdksavdecc_descriptor_strings_set_string_2(p->string_2, base, pos);
        jdksavdecc_descriptor_strings_set_string_3(p->string_3, base, pos);
        jdksavdecc_descriptor_strings_set_string_4(p->string_4, base, pos);
        jdksavdecc_descriptor_strings_set_string_5(p->string_5, base, pos);
        jdksavdecc_descriptor_strings_set_string_6(p->string_6, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_stream_port STREAM_PORT_INPUT and STREAM_PORT_OUTPUT
 * Descriptor - Clause 7.2.13  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_STREAM_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_STREAM_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the
 *DESCRIPTOR_STREAM_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the port_flags field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t port_flags value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_port_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_PORT_FLAGS);
}

/**
 * Store a uint16 value to the port_flags field of the DESCRIPTOR_STREAM_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t port_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_port_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_PORT_FLAGS);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the
 *DESCRIPTOR_STREAM_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the DESCRIPTOR_STREAM_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the number_of_clusters field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_clusters value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_number_of_clusters(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_CLUSTERS);
}

/**
 * Store a uint16 value to the number_of_clusters field of the
 *DESCRIPTOR_STREAM_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_clusters value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_number_of_clusters(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_CLUSTERS);
}

/**
 * Extract the uint16 value of the base_cluster field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_cluster value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_base_cluster(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_CLUSTER);
}

/**
 * Store a uint16 value to the base_cluster field of the DESCRIPTOR_STREAM_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_cluster value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_base_cluster(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_CLUSTER);
}

/**
 * Extract the uint16 value of the number_of_maps field of the
 *DESCRIPTOR_STREAM_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_maps value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_number_of_maps(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Store a uint16 value to the number_of_maps field of the
 *DESCRIPTOR_STREAM_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_maps value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_number_of_maps(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_NUMBER_OF_MAPS);
}

/**
 * Extract the uint16 value of the base_map field of the DESCRIPTOR_STREAM_PORT
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_map value
 */
static inline uint16_t jdksavdecc_descriptor_stream_port_get_base_map(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_MAP);
}

/**
 * Store a uint16 value to the base_map field of the DESCRIPTOR_STREAM_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_map value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_stream_port_set_base_map(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_STREAM_PORT_OFFSET_BASE_MAP);
}

/*@}*/

/** \addtogroup descriptor_stream_port STREAM_PORT_INPUT and STREAM_PORT_OUTPUT
 * Descriptor - Clause 7.2.13  */
/*@{*/

/// STREAM_PORT_INPUT and STREAM_PORT_OUTPUT Descriptor - Clause 7.2.13
struct jdksavdecc_descriptor_stream_port {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t clock_domain_index;
    uint16_t port_flags;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t number_of_clusters;
    uint16_t base_cluster;
    uint16_t number_of_maps;
    uint16_t base_map;
};

/**
 * Extract the jdksavdecc_descriptor_stream_port structure from a network
 *buffer.
 *
 *  - Clause 7.2.13
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_stream_port structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_stream_port_read(struct jdksavdecc_descriptor_stream_port *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_STREAM_PORT_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_stream_port_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_stream_port_get_descriptor_index(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_stream_port_get_clock_domain_index(base, pos);
        p->port_flags = jdksavdecc_descriptor_stream_port_get_port_flags(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_stream_port_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_stream_port_get_base_control(base, pos);
        p->number_of_clusters = jdksavdecc_descriptor_stream_port_get_number_of_clusters(base, pos);
        p->base_cluster = jdksavdecc_descriptor_stream_port_get_base_cluster(base, pos);
        p->number_of_maps = jdksavdecc_descriptor_stream_port_get_number_of_maps(base, pos);
        p->base_map = jdksavdecc_descriptor_stream_port_get_base_map(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_stream_port structure to a network buffer.
 *
 *  - Clause 7.2.13
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_stream_port structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_stream_port_write(struct jdksavdecc_descriptor_stream_port const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_STREAM_PORT_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_stream_port_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_stream_port_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_stream_port_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_stream_port_set_port_flags(p->port_flags, base, pos);
        jdksavdecc_descriptor_stream_port_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_stream_port_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_stream_port_set_number_of_clusters(p->number_of_clusters, base, pos);
        jdksavdecc_descriptor_stream_port_set_base_cluster(p->base_cluster, base, pos);
        jdksavdecc_descriptor_stream_port_set_number_of_maps(p->number_of_maps, base, pos);
        jdksavdecc_descriptor_stream_port_set_base_map(p->base_map, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_external_port EXTERNAL_PORT_INPUT and
 * EXTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.14  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the port_flags field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t port_flags value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_port_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_PORT_FLAGS);
}

/**
 * Store a uint16 value to the port_flags field of the DESCRIPTOR_EXTERNAL_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t port_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_port_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_PORT_FLAGS);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the DESCRIPTOR_EXTERNAL_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_external_port_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_EXTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint16 value of the jack_index field of the
 *DESCRIPTOR_EXTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t jack_index value
 */
static inline uint16_t jdksavdecc_descriptor_external_port_get_jack_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_JACK_INDEX);
}

/**
 * Store a uint16 value to the jack_index field of the DESCRIPTOR_EXTERNAL_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t jack_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_external_port_set_jack_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_OFFSET_JACK_INDEX);
}

/*@}*/

/** \addtogroup descriptor_external_port EXTERNAL_PORT_INPUT and
 * EXTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.14  */
/*@{*/

/// EXTERNAL_PORT_INPUT and EXTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.14
struct jdksavdecc_descriptor_external_port {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t clock_domain_index;
    uint16_t port_flags;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint32_t block_latency;
    uint16_t jack_index;
};

/**
 * Extract the jdksavdecc_descriptor_external_port_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.14
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_external_port structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_external_port_read(struct jdksavdecc_descriptor_external_port *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_external_port_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_external_port_get_descriptor_index(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_external_port_get_clock_domain_index(base, pos);
        p->port_flags = jdksavdecc_descriptor_external_port_get_port_flags(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_external_port_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_external_port_get_base_control(base, pos);
        p->signal_type = jdksavdecc_descriptor_external_port_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_external_port_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_external_port_get_signal_output(base, pos);
        p->block_latency = jdksavdecc_descriptor_external_port_get_block_latency(base, pos);
        p->jack_index = jdksavdecc_descriptor_external_port_get_jack_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_external_port_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.14
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_external_port structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_external_port_write(struct jdksavdecc_descriptor_external_port const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_EXTERNAL_PORT_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_external_port_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_external_port_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_external_port_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_external_port_set_port_flags(p->port_flags, base, pos);
        jdksavdecc_descriptor_external_port_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_external_port_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_external_port_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_external_port_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_external_port_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_external_port_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_external_port_set_jack_index(p->jack_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_internal_port INTERNAL_PORT_INPUT and
 * INTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.15  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the clock_domain_index field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_domain_index value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_clock_domain_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Store a uint16 value to the clock_domain_index field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_domain_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_clock_domain_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_CLOCK_DOMAIN_INDEX);
}

/**
 * Extract the uint16 value of the port_flags field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t port_flags value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_port_flags(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_PORT_FLAGS);
}

/**
 * Store a uint16 value to the port_flags field of the DESCRIPTOR_INTERNAL_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t port_flags value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_port_flags(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_PORT_FLAGS);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the DESCRIPTOR_INTERNAL_PORT
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_internal_port_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint16 value of the internal_index field of the
 *DESCRIPTOR_INTERNAL_PORT object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t internal_index value
 */
static inline uint16_t jdksavdecc_descriptor_internal_port_get_internal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_INTERNAL_INDEX);
}

/**
 * Store a uint16 value to the internal_index field of the
 *DESCRIPTOR_INTERNAL_PORT object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t internal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_internal_port_set_internal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_OFFSET_INTERNAL_INDEX);
}

/*@}*/

/** \addtogroup descriptor_internal_port INTERNAL_PORT_INPUT and
 * INTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.15  */
/*@{*/

/// INTERNAL_PORT_INPUT and INTERNAL_PORT_OUTPUT Descriptor - Clause 7.2.15
struct jdksavdecc_descriptor_internal_port {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t clock_domain_index;
    uint16_t port_flags;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint32_t block_latency;
    uint16_t internal_index;
};

/**
 * Extract the jdksavdecc_descriptor_internal_port_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.15
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_internal_port structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_internal_port_read(struct jdksavdecc_descriptor_internal_port *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_internal_port_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_internal_port_get_descriptor_index(base, pos);
        p->clock_domain_index = jdksavdecc_descriptor_internal_port_get_clock_domain_index(base, pos);
        p->port_flags = jdksavdecc_descriptor_internal_port_get_port_flags(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_internal_port_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_internal_port_get_base_control(base, pos);
        p->signal_type = jdksavdecc_descriptor_internal_port_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_internal_port_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_internal_port_get_signal_output(base, pos);
        p->block_latency = jdksavdecc_descriptor_internal_port_get_block_latency(base, pos);
        p->internal_index = jdksavdecc_descriptor_internal_port_get_internal_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_internal_port_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.15
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_internal_port structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_internal_port_write(struct jdksavdecc_descriptor_internal_port const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_INTERNAL_PORT_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_internal_port_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_internal_port_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_internal_port_set_clock_domain_index(p->clock_domain_index, base, pos);
        jdksavdecc_descriptor_internal_port_set_port_flags(p->port_flags, base, pos);
        jdksavdecc_descriptor_internal_port_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_internal_port_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_internal_port_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_internal_port_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_internal_port_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_internal_port_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_internal_port_set_internal_index(p->internal_index, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_audio_cluster AUDIO_CLUSTER Descriptor - Clause
 * 7.2.16  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_audio_cluster_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_AUDIO_CLUSTER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the DESCRIPTOR_AUDIO_CLUSTER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint32 value of the path_latency field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t path_latency value
 */
static inline uint32_t jdksavdecc_descriptor_audio_cluster_get_path_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_PATH_LATENCY);
}

/**
 * Store a uint32 value to the path_latency field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t path_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_path_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_PATH_LATENCY);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_audio_cluster_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint16 value of the channel_count field of the
 *DESCRIPTOR_AUDIO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t channel_count value
 */
static inline uint16_t jdksavdecc_descriptor_audio_cluster_get_channel_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_CHANNEL_COUNT);
}

/**
 * Store a uint16 value to the channel_count field of the
 *DESCRIPTOR_AUDIO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t channel_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_channel_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_CHANNEL_COUNT);
}

/**
 * Extract the uint8 value of the format field of the DESCRIPTOR_AUDIO_CLUSTER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t format value
 */
static inline uint8_t jdksavdecc_descriptor_audio_cluster_get_format(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_FORMAT);
}

/**
 * Store a uint8 value to the format field of the DESCRIPTOR_AUDIO_CLUSTER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_cluster_set_format(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_OFFSET_FORMAT);
}

/*@}*/

/** \addtogroup descriptor_audio_cluster AUDIO_CLUSTER Descriptor - Clause
 * 7.2.16  */
/*@{*/

/// AUDIO_CLUSTER Descriptor - Clause 7.2.16
struct jdksavdecc_descriptor_audio_cluster {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint32_t path_latency;
    uint32_t block_latency;
    uint16_t channel_count;
    uint8_t format;
};

/**
 * Extract the jdksavdecc_descriptor_audio_cluster_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.16
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_audio_cluster structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_audio_cluster_read(struct jdksavdecc_descriptor_audio_cluster *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_audio_cluster_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_audio_cluster_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_audio_cluster_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_audio_cluster_get_localized_description(base, pos);
        p->signal_type = jdksavdecc_descriptor_audio_cluster_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_audio_cluster_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_audio_cluster_get_signal_output(base, pos);
        p->path_latency = jdksavdecc_descriptor_audio_cluster_get_path_latency(base, pos);
        p->block_latency = jdksavdecc_descriptor_audio_cluster_get_block_latency(base, pos);
        p->channel_count = jdksavdecc_descriptor_audio_cluster_get_channel_count(base, pos);
        p->format = jdksavdecc_descriptor_audio_cluster_get_format(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_audio_cluster_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.16
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_audio_cluster structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_audio_cluster_write(struct jdksavdecc_descriptor_audio_cluster const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AUDIO_CLUSTER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_audio_cluster_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_path_latency(p->path_latency, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_channel_count(p->channel_count, base, pos);
        jdksavdecc_descriptor_audio_cluster_set_format(p->format, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_video_cluster VIDEO_CLUSTER Descriptor - Clause
 * 7.2.17  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_video_cluster_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_VIDEO_CLUSTER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the DESCRIPTOR_VIDEO_CLUSTER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint32 value of the path_latency field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t path_latency value
 */
static inline uint32_t jdksavdecc_descriptor_video_cluster_get_path_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_PATH_LATENCY);
}

/**
 * Store a uint32 value to the path_latency field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t path_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_path_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_PATH_LATENCY);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_video_cluster_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint8 value of the format field of the DESCRIPTOR_VIDEO_CLUSTER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint8_t format value
 */
static inline uint8_t jdksavdecc_descriptor_video_cluster_get_format(void const *base, ssize_t pos) {
    return jdksavdecc_uint8_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_FORMAT);
}

/**
 * Store a uint8 value to the format field of the DESCRIPTOR_VIDEO_CLUSTER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint8_t format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_format(uint8_t v, void *base, ssize_t pos) {
    jdksavdecc_uint8_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_FORMAT);
}

/**
 * Extract the uint32 value of the current_format_specific field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t current_format_specific value
 */
static inline uint32_t jdksavdecc_descriptor_video_cluster_get_current_format_specific(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_FORMAT_SPECIFIC);
}

/**
 * Store a uint32 value to the current_format_specific field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t current_format_specific value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_current_format_specific(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_FORMAT_SPECIFIC);
}

/**
 * Extract the uint16 value of the supported_format_specifics_offset field of
 *the DESCRIPTOR_VIDEO_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_format_specifics_offset value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_format_specifics_offset(void const *base,
                                                                                                 ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS_OFFSET);
}

/**
 * Store a uint16 value to the supported_format_specifics_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_format_specifics_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_video_cluster_set_supported_format_specifics_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS_OFFSET);
}

/**
 * Extract the uint16 value of the supported_format_specifics_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_format_specifics_count value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_format_specifics_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS_COUNT);
}

/**
 * Store a uint16 value to the supported_format_specifics_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_format_specifics_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_video_cluster_set_supported_format_specifics_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_FORMAT_SPECIFICS_COUNT);
}

/**
 * Extract the uint32 value of the current_sampling_rate field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t current_sampling_rate value
 */
static inline uint32_t jdksavdecc_descriptor_video_cluster_get_current_sampling_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_SAMPLING_RATE);
}

/**
 * Store a uint32 value to the current_sampling_rate field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t current_sampling_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_current_sampling_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_SAMPLING_RATE);
}

/**
 * Extract the uint16 value of the supported_sampling_rates_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_sampling_rates_offset value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_sampling_rates_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_OFFSET);
}

/**
 * Store a uint16 value to the supported_sampling_rates_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_sampling_rates_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_video_cluster_set_supported_sampling_rates_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_OFFSET);
}

/**
 * Extract the uint16 value of the supported_sampling_rates_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_sampling_rates_count value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_sampling_rates_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_COUNT);
}

/**
 * Store a uint16 value to the supported_sampling_rates_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_sampling_rates_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_sampling_rates_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_COUNT);
}

/**
 * Extract the uint16 value of the current_aspect_ratio field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t current_aspect_ratio value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_current_aspect_ratio(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_ASPECT_RATIO);
}

/**
 * Store a uint16 value to the current_aspect_ratio field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t current_aspect_ratio value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_current_aspect_ratio(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_ASPECT_RATIO);
}

/**
 * Extract the uint16 value of the supported_aspect_ratios_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_aspect_ratios_offset value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_aspect_ratios_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_ASPECT_RATIOS_OFFSET);
}

/**
 * Store a uint16 value to the supported_aspect_ratios_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_aspect_ratios_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_aspect_ratios_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_ASPECT_RATIOS_OFFSET);
}

/**
 * Extract the uint16 value of the supported_aspect_ratios_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_aspect_ratios_count value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_aspect_ratios_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_ASPECT_RATIOS_COUNT);
}

/**
 * Store a uint16 value to the supported_aspect_ratios_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_aspect_ratios_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_aspect_ratios_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_ASPECT_RATIOS_COUNT);
}

/**
 * Extract the uint32 value of the current_size field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t current_size value
 */
static inline uint32_t jdksavdecc_descriptor_video_cluster_get_current_size(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_SIZE);
}

/**
 * Store a uint32 value to the current_size field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t current_size value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_current_size(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_SIZE);
}

/**
 * Extract the uint16 value of the supported_sizes_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_sizes_offset value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_sizes_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SIZES_OFFSET);
}

/**
 * Store a uint16 value to the supported_sizes_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_sizes_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_sizes_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SIZES_OFFSET);
}

/**
 * Extract the uint16 value of the supported_sizes_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_sizes_count value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_sizes_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SIZES_COUNT);
}

/**
 * Store a uint16 value to the supported_sizes_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_sizes_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_sizes_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_SIZES_COUNT);
}

/**
 * Extract the uint16 value of the current_color_space field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t current_color_space value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_current_color_space(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_COLOR_SPACE);
}

/**
 * Store a uint16 value to the current_color_space field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t current_color_space value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_current_color_space(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_CURRENT_COLOR_SPACE);
}

/**
 * Extract the uint16 value of the supported_color_spaces_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_color_spaces_offset value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_color_spaces_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_COLOR_SPACES_OFFSET);
}

/**
 * Store a uint16 value to the supported_color_spaces_offset field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_color_spaces_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_color_spaces_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_COLOR_SPACES_OFFSET);
}

/**
 * Extract the uint16 value of the supported_color_spaces_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_color_spaces_count value
 */
static inline uint16_t jdksavdecc_descriptor_video_cluster_get_supported_color_spaces_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_COLOR_SPACES_COUNT);
}

/**
 * Store a uint16 value to the supported_color_spaces_count field of the
 *DESCRIPTOR_VIDEO_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_color_spaces_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_cluster_set_supported_color_spaces_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_OFFSET_SUPPORTED_COLOR_SPACES_COUNT);
}

/*@}*/

/** \addtogroup descriptor_video_cluster VIDEO_CLUSTER Descriptor - Clause
 * 7.2.17  */
/*@{*/

/// VIDEO_CLUSTER Descriptor - Clause 7.2.17
struct jdksavdecc_descriptor_video_cluster {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint32_t path_latency;
    uint32_t block_latency;
    uint8_t format;
    uint32_t current_format_specific;
    uint16_t supported_format_specifics_offset;
    uint16_t supported_format_specifics_count;
    uint32_t current_sampling_rate;
    uint16_t supported_sampling_rates_offset;
    uint16_t supported_sampling_rates_count;
    uint16_t current_aspect_ratio;
    uint16_t supported_aspect_ratios_offset;
    uint16_t supported_aspect_ratios_count;
    uint32_t current_size;
    uint16_t supported_sizes_offset;
    uint16_t supported_sizes_count;
    uint16_t current_color_space;
    uint16_t supported_color_spaces_offset;
    uint16_t supported_color_spaces_count;
};

/**
 * Extract the jdksavdecc_descriptor_video_cluster_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.17
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_video_cluster structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_video_cluster_read(struct jdksavdecc_descriptor_video_cluster *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_video_cluster_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_video_cluster_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_video_cluster_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_video_cluster_get_localized_description(base, pos);
        p->signal_type = jdksavdecc_descriptor_video_cluster_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_video_cluster_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_video_cluster_get_signal_output(base, pos);
        p->path_latency = jdksavdecc_descriptor_video_cluster_get_path_latency(base, pos);
        p->block_latency = jdksavdecc_descriptor_video_cluster_get_block_latency(base, pos);
        p->format = jdksavdecc_descriptor_video_cluster_get_format(base, pos);
        p->current_format_specific = jdksavdecc_descriptor_video_cluster_get_current_format_specific(base, pos);
        p->supported_format_specifics_offset
            = jdksavdecc_descriptor_video_cluster_get_supported_format_specifics_offset(base, pos);
        p->supported_format_specifics_count
            = jdksavdecc_descriptor_video_cluster_get_supported_format_specifics_count(base, pos);
        p->current_sampling_rate = jdksavdecc_descriptor_video_cluster_get_current_sampling_rate(base, pos);
        p->supported_sampling_rates_offset = jdksavdecc_descriptor_video_cluster_get_supported_sampling_rates_offset(base, pos);
        p->supported_sampling_rates_count = jdksavdecc_descriptor_video_cluster_get_supported_sampling_rates_count(base, pos);
        p->current_aspect_ratio = jdksavdecc_descriptor_video_cluster_get_current_aspect_ratio(base, pos);
        p->supported_aspect_ratios_offset = jdksavdecc_descriptor_video_cluster_get_supported_aspect_ratios_offset(base, pos);
        p->supported_aspect_ratios_count = jdksavdecc_descriptor_video_cluster_get_supported_aspect_ratios_count(base, pos);
        p->current_size = jdksavdecc_descriptor_video_cluster_get_current_size(base, pos);
        p->supported_sizes_offset = jdksavdecc_descriptor_video_cluster_get_supported_sizes_offset(base, pos);
        p->supported_sizes_count = jdksavdecc_descriptor_video_cluster_get_supported_sizes_count(base, pos);
        p->current_color_space = jdksavdecc_descriptor_video_cluster_get_current_color_space(base, pos);
        p->supported_color_spaces_offset = jdksavdecc_descriptor_video_cluster_get_supported_color_spaces_offset(base, pos);
        p->supported_color_spaces_count = jdksavdecc_descriptor_video_cluster_get_supported_color_spaces_count(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_video_cluster_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.17
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_video_cluster structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_video_cluster_write(struct jdksavdecc_descriptor_video_cluster const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_VIDEO_CLUSTER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_video_cluster_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_video_cluster_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_video_cluster_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_video_cluster_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_video_cluster_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_video_cluster_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_video_cluster_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_video_cluster_set_path_latency(p->path_latency, base, pos);
        jdksavdecc_descriptor_video_cluster_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_video_cluster_set_format(p->format, base, pos);
        jdksavdecc_descriptor_video_cluster_set_current_format_specific(p->current_format_specific, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_format_specifics_offset(
            p->supported_format_specifics_offset, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_format_specifics_count(
            p->supported_format_specifics_count, base, pos);
        jdksavdecc_descriptor_video_cluster_set_current_sampling_rate(p->current_sampling_rate, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_sampling_rates_offset(p->supported_sampling_rates_offset, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_sampling_rates_count(p->supported_sampling_rates_count, base, pos);
        jdksavdecc_descriptor_video_cluster_set_current_aspect_ratio(p->current_aspect_ratio, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_aspect_ratios_offset(p->supported_aspect_ratios_offset, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_aspect_ratios_count(p->supported_aspect_ratios_count, base, pos);
        jdksavdecc_descriptor_video_cluster_set_current_size(p->current_size, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_sizes_offset(p->supported_sizes_offset, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_sizes_count(p->supported_sizes_count, base, pos);
        jdksavdecc_descriptor_video_cluster_set_current_color_space(p->current_color_space, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_color_spaces_offset(p->supported_color_spaces_offset, base, pos);
        jdksavdecc_descriptor_video_cluster_set_supported_color_spaces_count(p->supported_color_spaces_count, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_sensor_cluster SENSOR_CLUSTER Descriptor - Clause
 * 7.2.18  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_sensor_cluster_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint32 value of the path_latency field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t path_latency value
 */
static inline uint32_t jdksavdecc_descriptor_sensor_cluster_get_path_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_PATH_LATENCY);
}

/**
 * Store a uint32 value to the path_latency field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t path_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_path_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_PATH_LATENCY);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_sensor_cluster_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the eui64 value of the current_format field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 current_format value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_sensor_cluster_get_current_format(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_CURRENT_FORMAT);
}

/**
 * Store a eui64 value to the current_format field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 current_format value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_current_format(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_CURRENT_FORMAT);
}

/**
 * Extract the uint16 value of the supported_formats_offset field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_formats_offset value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_supported_formats_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS_OFFSET);
}

/**
 * Store a uint16 value to the supported_formats_offset field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_formats_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_supported_formats_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS_OFFSET);
}

/**
 * Extract the uint16 value of the supported_formats_count field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_formats_count value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_supported_formats_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS_COUNT);
}

/**
 * Store a uint16 value to the supported_formats_count field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_formats_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_supported_formats_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_FORMATS_COUNT);
}

/**
 * Extract the uint32 value of the current_sampling_rate field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t current_sampling_rate value
 */
static inline uint32_t jdksavdecc_descriptor_sensor_cluster_get_current_sampling_rate(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_CURRENT_SAMPLING_RATE);
}

/**
 * Store a uint32 value to the current_sampling_rate field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t current_sampling_rate value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_cluster_set_current_sampling_rate(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_CURRENT_SAMPLING_RATE);
}

/**
 * Extract the uint16 value of the supported_sampling_rates_offset field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_sampling_rates_offset value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_supported_sampling_rates_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_OFFSET);
}

/**
 * Store a uint16 value to the supported_sampling_rates_offset field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_sampling_rates_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_sensor_cluster_set_supported_sampling_rates_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_OFFSET);
}

/**
 * Extract the uint16 value of the supported_sampling_rates_count field of the
 *DESCRIPTOR_SENSOR_CLUSTER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t supported_sampling_rates_count value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_cluster_get_supported_sampling_rates_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_COUNT);
}

/**
 * Store a uint16 value to the supported_sampling_rates_count field of the
 *DESCRIPTOR_SENSOR_CLUSTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t supported_sampling_rates_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_sensor_cluster_set_supported_sampling_rates_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_OFFSET_SUPPORTED_SAMPLING_RATES_COUNT);
}

/*@}*/

/** \addtogroup descriptor_sensor_cluster SENSOR_CLUSTER Descriptor - Clause
 * 7.2.18  */
/*@{*/

/// SENSOR_CLUSTER Descriptor - Clause 7.2.18
struct jdksavdecc_descriptor_sensor_cluster {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint32_t path_latency;
    uint32_t block_latency;
    struct jdksavdecc_eui64 current_format;
    uint16_t supported_formats_offset;
    uint16_t supported_formats_count;
    uint32_t current_sampling_rate;
    uint16_t supported_sampling_rates_offset;
    uint16_t supported_sampling_rates_count;
};

/**
 * Extract the jdksavdecc_descriptor_sensor_cluster_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.18
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_sensor_cluster structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_sensor_cluster_read(struct jdksavdecc_descriptor_sensor_cluster *p,
                                                                void const *base,
                                                                ssize_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_sensor_cluster_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_sensor_cluster_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_sensor_cluster_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_sensor_cluster_get_localized_description(base, pos);
        p->signal_type = jdksavdecc_descriptor_sensor_cluster_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_sensor_cluster_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_sensor_cluster_get_signal_output(base, pos);
        p->path_latency = jdksavdecc_descriptor_sensor_cluster_get_path_latency(base, pos);
        p->block_latency = jdksavdecc_descriptor_sensor_cluster_get_block_latency(base, pos);
        p->current_format = jdksavdecc_descriptor_sensor_cluster_get_current_format(base, pos);
        p->supported_formats_offset = jdksavdecc_descriptor_sensor_cluster_get_supported_formats_offset(base, pos);
        p->supported_formats_count = jdksavdecc_descriptor_sensor_cluster_get_supported_formats_count(base, pos);
        p->current_sampling_rate = jdksavdecc_descriptor_sensor_cluster_get_current_sampling_rate(base, pos);
        p->supported_sampling_rates_offset
            = jdksavdecc_descriptor_sensor_cluster_get_supported_sampling_rates_offset(base, pos);
        p->supported_sampling_rates_count = jdksavdecc_descriptor_sensor_cluster_get_supported_sampling_rates_count(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_sensor_cluster_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.18
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_sensor_cluster structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_sensor_cluster_write(struct jdksavdecc_descriptor_sensor_cluster const *p,
                                                                 void *base,
                                                                 size_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SENSOR_CLUSTER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_sensor_cluster_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_path_latency(p->path_latency, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_current_format(p->current_format, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_supported_formats_offset(p->supported_formats_offset, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_supported_formats_count(p->supported_formats_count, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_current_sampling_rate(p->current_sampling_rate, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_supported_sampling_rates_offset(p->supported_sampling_rates_offset, base, pos);
        jdksavdecc_descriptor_sensor_cluster_set_supported_sampling_rates_count(p->supported_sampling_rates_count, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_audio_map AUDIO_MAP Descriptor - Clause 7.2.19  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_audio_map_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_AUDIO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_map_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_audio_map_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_AUDIO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_map_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the mappings_offset field of the
 *DESCRIPTOR_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mappings_offset value
 */
static inline uint16_t jdksavdecc_descriptor_audio_map_get_mappings_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_MAPPINGS_OFFSET);
}

/**
 * Store a uint16 value to the mappings_offset field of the DESCRIPTOR_AUDIO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mappings_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_map_set_mappings_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_MAPPINGS_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *DESCRIPTOR_AUDIO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_descriptor_audio_map_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *DESCRIPTOR_AUDIO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_audio_map_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_OFFSET_NUMBER_OF_MAPPINGS);
}

/*@}*/

/** \addtogroup descriptor_audio_map AUDIO_MAP Descriptor - Clause 7.2.19  */
/*@{*/

/// AUDIO_MAP Descriptor - Clause 7.2.19
struct jdksavdecc_descriptor_audio_map {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t mappings_offset;
    uint16_t number_of_mappings;
};

/**
 * Extract the jdksavdecc_descriptor_audio_map_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.19
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_audio_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_audio_map_read(struct jdksavdecc_descriptor_audio_map *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_audio_map_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_audio_map_get_descriptor_index(base, pos);
        p->mappings_offset = jdksavdecc_descriptor_audio_map_get_mappings_offset(base, pos);
        p->number_of_mappings = jdksavdecc_descriptor_audio_map_get_number_of_mappings(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_audio_map_t structure to a network buffer.
 *
 *  - Clause 7.2.19
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_audio_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_audio_map_write(struct jdksavdecc_descriptor_audio_map const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_AUDIO_MAP_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_audio_map_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_audio_map_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_audio_map_set_mappings_offset(p->mappings_offset, base, pos);
        jdksavdecc_descriptor_audio_map_set_number_of_mappings(p->number_of_mappings, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_video_map VIDEO_MAP Descriptor - Clause 7.2.20  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_video_map_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_VIDEO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_map_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_video_map_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_VIDEO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_map_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the mappings_offset field of the
 *DESCRIPTOR_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mappings_offset value
 */
static inline uint16_t jdksavdecc_descriptor_video_map_get_mappings_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_MAPPINGS_OFFSET);
}

/**
 * Store a uint16 value to the mappings_offset field of the DESCRIPTOR_VIDEO_MAP
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mappings_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_map_set_mappings_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_MAPPINGS_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *DESCRIPTOR_VIDEO_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_descriptor_video_map_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *DESCRIPTOR_VIDEO_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_video_map_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_OFFSET_NUMBER_OF_MAPPINGS);
}

/*@}*/

/** \addtogroup descriptor_video_map VIDEO_MAP Descriptor - Clause 7.2.20  */
/*@{*/

/// VIDEO_MAP Descriptor - Clause 7.2.20
struct jdksavdecc_descriptor_video_map {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t mappings_offset;
    uint16_t number_of_mappings;
};

/**
 * Extract the jdksavdecc_descriptor_video_map_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.20
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_video_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_video_map_read(struct jdksavdecc_descriptor_video_map *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_video_map_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_video_map_get_descriptor_index(base, pos);
        p->mappings_offset = jdksavdecc_descriptor_video_map_get_mappings_offset(base, pos);
        p->number_of_mappings = jdksavdecc_descriptor_video_map_get_number_of_mappings(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_video_map_t structure to a network buffer.
 *
 *  - Clause 7.2.20
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_video_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_video_map_write(struct jdksavdecc_descriptor_video_map const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_VIDEO_MAP_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_video_map_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_video_map_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_video_map_set_mappings_offset(p->mappings_offset, base, pos);
        jdksavdecc_descriptor_video_map_set_number_of_mappings(p->number_of_mappings, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_sensor_map SENSOR_MAP Descriptor - Clause 7.2.21  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_map_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_map_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_map_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_map_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the mappings_offset field of the
 *DESCRIPTOR_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t mappings_offset value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_map_get_mappings_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_MAPPINGS_OFFSET);
}

/**
 * Store a uint16 value to the mappings_offset field of the
 *DESCRIPTOR_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t mappings_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_map_set_mappings_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_MAPPINGS_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_mappings field of the
 *DESCRIPTOR_SENSOR_MAP object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_mappings value
 */
static inline uint16_t jdksavdecc_descriptor_sensor_map_get_number_of_mappings(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_NUMBER_OF_MAPPINGS);
}

/**
 * Store a uint16 value to the number_of_mappings field of the
 *DESCRIPTOR_SENSOR_MAP object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_mappings value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_sensor_map_set_number_of_mappings(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_OFFSET_NUMBER_OF_MAPPINGS);
}

/*@}*/

/** \addtogroup descriptor_sensor_map SENSOR_MAP Descriptor - Clause 7.2.21  */
/*@{*/

/// SENSOR_MAP Descriptor - Clause 7.2.21
struct jdksavdecc_descriptor_sensor_map {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t mappings_offset;
    uint16_t number_of_mappings;
};

/**
 * Extract the jdksavdecc_descriptor_sensor_map_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.21
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_sensor_map structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_sensor_map_read(struct jdksavdecc_descriptor_sensor_map *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_sensor_map_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_sensor_map_get_descriptor_index(base, pos);
        p->mappings_offset = jdksavdecc_descriptor_sensor_map_get_mappings_offset(base, pos);
        p->number_of_mappings = jdksavdecc_descriptor_sensor_map_get_number_of_mappings(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_sensor_map_t structure to a network buffer.
 *
 *  - Clause 7.2.21
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_sensor_map structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_sensor_map_write(struct jdksavdecc_descriptor_sensor_map const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SENSOR_MAP_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_sensor_map_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_sensor_map_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_sensor_map_set_mappings_offset(p->mappings_offset, base, pos);
        jdksavdecc_descriptor_sensor_map_set_number_of_mappings(p->number_of_mappings, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_control CONTROL Descriptor - Clause 7.2.22  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_control_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_control_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_control_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the control_value_type field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_value_type value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_control_value_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Store a uint16 value to the control_value_type field of the
 *DESCRIPTOR_CONTROL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_value_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_control_value_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Extract the eui64 value of the control_type field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 control_type value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_control_get_control_type(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_TYPE);
}

/**
 * Store a eui64 value to the control_type field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 control_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_control_type(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_CONTROL_TYPE);
}

/**
 * Extract the uint32 value of the reset_time field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t reset_time value
 */
static inline uint32_t jdksavdecc_descriptor_control_get_reset_time(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_RESET_TIME);
}

/**
 * Store a uint32 value to the reset_time field of the DESCRIPTOR_CONTROL object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t reset_time value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_reset_time(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_RESET_TIME);
}

/**
 * Extract the uint16 value of the values_offset field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t values_offset value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_values_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_VALUES_OFFSET);
}

/**
 * Store a uint16 value to the values_offset field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t values_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_values_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_VALUES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_values field of the
 *DESCRIPTOR_CONTROL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_values value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_number_of_values(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_NUMBER_OF_VALUES);
}

/**
 * Store a uint16 value to the number_of_values field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_values value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_number_of_values(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_NUMBER_OF_VALUES);
}

/**
 * Extract the uint16 value of the signal_type field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the DESCRIPTOR_CONTROL
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_control_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the DESCRIPTOR_CONTROL
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_OFFSET_SIGNAL_OUTPUT);
}

/*@}*/

/** \addtogroup descriptor_control CONTROL Descriptor - Clause 7.2.22  */
/*@{*/

/// CONTROL Descriptor - Clause 7.2.22
struct jdksavdecc_descriptor_control {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t control_value_type;
    struct jdksavdecc_eui64 control_type;
    uint32_t reset_time;
    uint16_t values_offset;
    uint16_t number_of_values;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
};

/**
 * Extract the jdksavdecc_descriptor_control_t structure from a network buffer.
 *
 *  - Clause 7.2.22
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_control structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_control_read(struct jdksavdecc_descriptor_control *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CONTROL_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_control_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_control_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_control_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_control_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_control_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_control_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_control_get_control_domain(base, pos);
        p->control_value_type = jdksavdecc_descriptor_control_get_control_value_type(base, pos);
        p->control_type = jdksavdecc_descriptor_control_get_control_type(base, pos);
        p->reset_time = jdksavdecc_descriptor_control_get_reset_time(base, pos);
        p->values_offset = jdksavdecc_descriptor_control_get_values_offset(base, pos);
        p->number_of_values = jdksavdecc_descriptor_control_get_number_of_values(base, pos);
        p->signal_type = jdksavdecc_descriptor_control_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_control_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_control_get_signal_output(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_control_t structure to a network buffer.
 *
 *  - Clause 7.2.22
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_control structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_control_write(struct jdksavdecc_descriptor_control const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CONTROL_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_control_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_control_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_control_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_control_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_control_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_control_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_control_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_control_set_control_value_type(p->control_value_type, base, pos);
        jdksavdecc_descriptor_control_set_control_type(p->control_type, base, pos);
        jdksavdecc_descriptor_control_set_reset_time(p->reset_time, base, pos);
        jdksavdecc_descriptor_control_set_values_offset(p->values_offset, base, pos);
        jdksavdecc_descriptor_control_set_number_of_values(p->number_of_values, base, pos);
        jdksavdecc_descriptor_control_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_control_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_control_set_signal_output(p->signal_output, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_signal_selector SIGNAL_SELECTOR Descriptor - Clause
 * 7.2.23  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_signal_selector_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_selector_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_selector_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the sources_offset field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sources_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_sources_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_SOURCES_OFFSET);
}

/**
 * Store a uint16 value to the sources_offset field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sources_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_sources_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_SOURCES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_sources field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_sources value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_number_of_sources(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Store a uint16 value to the number_of_sources field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_sources value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_number_of_sources(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Extract the uint16 value of the current_signal_type field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t current_signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_current_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the current_signal_type field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t current_signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_current_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the current_signal_index field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t current_signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_current_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the current_signal_index field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t current_signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_current_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the current_signal_output field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t current_signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_current_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the current_signal_output field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t current_signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_current_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_CURRENT_SIGNAL_OUTPUT);
}

/**
 * Extract the uint16 value of the default_signal_type field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t default_signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_default_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the default_signal_type field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t default_signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_default_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the default_signal_index field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t default_signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_default_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the default_signal_index field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t default_signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_default_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the default_signal_output field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t default_signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_signal_selector_get_default_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the default_signal_output field of the
 *DESCRIPTOR_SIGNAL_SELECTOR object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t default_signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_selector_set_default_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_OFFSET_DEFAULT_SIGNAL_OUTPUT);
}

/*@}*/

/** \addtogroup descriptor_signal_selector SIGNAL_SELECTOR Descriptor - Clause
 * 7.2.23  */
/*@{*/

/// SIGNAL_SELECTOR Descriptor - Clause 7.2.23
struct jdksavdecc_descriptor_signal_selector {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t sources_offset;
    uint16_t number_of_sources;
    uint16_t current_signal_type;
    uint16_t current_signal_index;
    uint16_t current_signal_output;
    uint16_t default_signal_type;
    uint16_t default_signal_index;
    uint16_t default_signal_output;
};

/**
 * Extract the jdksavdecc_descriptor_signal_selector_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.23
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_signal_selector structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_selector_read(struct jdksavdecc_descriptor_signal_selector *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_signal_selector_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_signal_selector_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_signal_selector_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_signal_selector_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_signal_selector_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_signal_selector_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_signal_selector_get_control_domain(base, pos);
        p->sources_offset = jdksavdecc_descriptor_signal_selector_get_sources_offset(base, pos);
        p->number_of_sources = jdksavdecc_descriptor_signal_selector_get_number_of_sources(base, pos);
        p->current_signal_type = jdksavdecc_descriptor_signal_selector_get_current_signal_type(base, pos);
        p->current_signal_index = jdksavdecc_descriptor_signal_selector_get_current_signal_index(base, pos);
        p->current_signal_output = jdksavdecc_descriptor_signal_selector_get_current_signal_output(base, pos);
        p->default_signal_type = jdksavdecc_descriptor_signal_selector_get_default_signal_type(base, pos);
        p->default_signal_index = jdksavdecc_descriptor_signal_selector_get_default_signal_index(base, pos);
        p->default_signal_output = jdksavdecc_descriptor_signal_selector_get_default_signal_output(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_signal_selector_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.23
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_signal_selector structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_selector_write(struct jdksavdecc_descriptor_signal_selector const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_SELECTOR_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_signal_selector_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_signal_selector_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_signal_selector_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_signal_selector_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_signal_selector_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_signal_selector_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_signal_selector_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_signal_selector_set_sources_offset(p->sources_offset, base, pos);
        jdksavdecc_descriptor_signal_selector_set_number_of_sources(p->number_of_sources, base, pos);
        jdksavdecc_descriptor_signal_selector_set_current_signal_type(p->current_signal_type, base, pos);
        jdksavdecc_descriptor_signal_selector_set_current_signal_index(p->current_signal_index, base, pos);
        jdksavdecc_descriptor_signal_selector_set_current_signal_output(p->current_signal_output, base, pos);
        jdksavdecc_descriptor_signal_selector_set_default_signal_type(p->default_signal_type, base, pos);
        jdksavdecc_descriptor_signal_selector_set_default_signal_index(p->default_signal_index, base, pos);
        jdksavdecc_descriptor_signal_selector_set_default_signal_output(p->default_signal_output, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_mixer MIXER Descriptor - Clause 7.2.24  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_mixer_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_MIXER object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_MIXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_mixer_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_mixer_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the control_value_type field of the
 *DESCRIPTOR_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_value_type value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_control_value_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Store a uint16 value to the control_value_type field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_value_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_control_value_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Extract the uint16 value of the sources_offset field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sources_offset value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_sources_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_SOURCES_OFFSET);
}

/**
 * Store a uint16 value to the sources_offset field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sources_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_sources_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_SOURCES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_sources field of the
 *DESCRIPTOR_MIXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_sources value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_number_of_sources(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Store a uint16 value to the number_of_sources field of the DESCRIPTOR_MIXER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_sources value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_number_of_sources(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Extract the uint16 value of the value_offset field of the DESCRIPTOR_MIXER
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t value_offset value
 */
static inline uint16_t jdksavdecc_descriptor_mixer_get_value_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_VALUE_OFFSET);
}

/**
 * Store a uint16 value to the value_offset field of the DESCRIPTOR_MIXER object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t value_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_mixer_set_value_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MIXER_OFFSET_VALUE_OFFSET);
}

/*@}*/

/** \addtogroup descriptor_mixer MIXER Descriptor - Clause 7.2.24  */
/*@{*/

/// MIXER Descriptor - Clause 7.2.24
struct jdksavdecc_descriptor_mixer {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t control_value_type;
    uint16_t sources_offset;
    uint16_t number_of_sources;
    uint16_t value_offset;
};

/**
 * Extract the jdksavdecc_descriptor_mixer_t structure from a network buffer.
 *
 *  - Clause 7.2.24
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_mixer structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_mixer_read(struct jdksavdecc_descriptor_mixer *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MIXER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_mixer_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_mixer_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_mixer_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_mixer_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_mixer_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_mixer_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_mixer_get_control_domain(base, pos);
        p->control_value_type = jdksavdecc_descriptor_mixer_get_control_value_type(base, pos);
        p->sources_offset = jdksavdecc_descriptor_mixer_get_sources_offset(base, pos);
        p->number_of_sources = jdksavdecc_descriptor_mixer_get_number_of_sources(base, pos);
        p->value_offset = jdksavdecc_descriptor_mixer_get_value_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_mixer_t structure to a network buffer.
 *
 *  - Clause 7.2.24
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_mixer structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_mixer_write(struct jdksavdecc_descriptor_mixer const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MIXER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_mixer_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_mixer_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_mixer_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_mixer_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_mixer_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_mixer_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_mixer_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_mixer_set_control_value_type(p->control_value_type, base, pos);
        jdksavdecc_descriptor_mixer_set_sources_offset(p->sources_offset, base, pos);
        jdksavdecc_descriptor_mixer_set_number_of_sources(p->number_of_sources, base, pos);
        jdksavdecc_descriptor_mixer_set_value_offset(p->value_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_matrix MATRIX Descriptor - Clause 7.2.25  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the DESCRIPTOR_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_matrix_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_MATRIX object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_MATRIX object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the DESCRIPTOR_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_matrix_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_matrix_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the DESCRIPTOR_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the control_value_type field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_value_type value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_control_value_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Store a uint16 value to the control_value_type field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_value_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_control_value_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Extract the eui64 value of the control_type field of the DESCRIPTOR_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_eui64 control_type value
 */
static inline struct jdksavdecc_eui64 jdksavdecc_descriptor_matrix_get_control_type(void const *base, ssize_t pos) {
    return jdksavdecc_eui64_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_TYPE);
}

/**
 * Store a eui64 value to the control_type field of the DESCRIPTOR_MATRIX object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_eui64 control_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_control_type(struct jdksavdecc_eui64 v, void *base, ssize_t pos) {
    jdksavdecc_eui64_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_CONTROL_TYPE);
}

/**
 * Extract the uint16 value of the width field of the DESCRIPTOR_MATRIX object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t width value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_width(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_WIDTH);
}

/**
 * Store a uint16 value to the width field of the DESCRIPTOR_MATRIX object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t width value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_width(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_WIDTH);
}

/**
 * Extract the uint16 value of the height field of the DESCRIPTOR_MATRIX object
 *from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t height value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_height(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_HEIGHT);
}

/**
 * Store a uint16 value to the height field of the DESCRIPTOR_MATRIX object to a
 *network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t height value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_height(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_HEIGHT);
}

/**
 * Extract the uint16 value of the values_offset field of the DESCRIPTOR_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t values_offset value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_values_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_VALUES_OFFSET);
}

/**
 * Store a uint16 value to the values_offset field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t values_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_values_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_VALUES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_values field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_values value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_number_of_values(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_NUMBER_OF_VALUES);
}

/**
 * Store a uint16 value to the number_of_values field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_values value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_number_of_values(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_NUMBER_OF_VALUES);
}

/**
 * Extract the uint16 value of the number_of_sources field of the
 *DESCRIPTOR_MATRIX object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_sources value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_number_of_sources(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Store a uint16 value to the number_of_sources field of the DESCRIPTOR_MATRIX
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_sources value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_number_of_sources(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Extract the uint16 value of the base_source field of the DESCRIPTOR_MATRIX
 *object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_source value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_get_base_source(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_BASE_SOURCE);
}

/**
 * Store a uint16 value to the base_source field of the DESCRIPTOR_MATRIX object
 *to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_source value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_set_base_source(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_OFFSET_BASE_SOURCE);
}

/*@}*/

/** \addtogroup descriptor_matrix MATRIX Descriptor - Clause 7.2.25  */
/*@{*/

/// MATRIX Descriptor - Clause 7.2.25
struct jdksavdecc_descriptor_matrix {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t control_value_type;
    struct jdksavdecc_eui64 control_type;
    uint16_t width;
    uint16_t height;
    uint16_t values_offset;
    uint16_t number_of_values;
    uint16_t number_of_sources;
    uint16_t base_source;
};

/**
 * Extract the jdksavdecc_descriptor_matrix_t structure from a network buffer.
 *
 *  - Clause 7.2.25
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_matrix structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_matrix_read(struct jdksavdecc_descriptor_matrix *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MATRIX_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_matrix_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_matrix_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_matrix_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_matrix_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_matrix_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_matrix_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_matrix_get_control_domain(base, pos);
        p->control_value_type = jdksavdecc_descriptor_matrix_get_control_value_type(base, pos);
        p->control_type = jdksavdecc_descriptor_matrix_get_control_type(base, pos);
        p->width = jdksavdecc_descriptor_matrix_get_width(base, pos);
        p->height = jdksavdecc_descriptor_matrix_get_height(base, pos);
        p->values_offset = jdksavdecc_descriptor_matrix_get_values_offset(base, pos);
        p->number_of_values = jdksavdecc_descriptor_matrix_get_number_of_values(base, pos);
        p->number_of_sources = jdksavdecc_descriptor_matrix_get_number_of_sources(base, pos);
        p->base_source = jdksavdecc_descriptor_matrix_get_base_source(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_matrix_t structure to a network buffer.
 *
 *  - Clause 7.2.25
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_matrix structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_matrix_write(struct jdksavdecc_descriptor_matrix const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MATRIX_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_matrix_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_matrix_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_matrix_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_matrix_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_matrix_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_matrix_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_matrix_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_matrix_set_control_value_type(p->control_value_type, base, pos);
        jdksavdecc_descriptor_matrix_set_control_type(p->control_type, base, pos);
        jdksavdecc_descriptor_matrix_set_width(p->width, base, pos);
        jdksavdecc_descriptor_matrix_set_height(p->height, base, pos);
        jdksavdecc_descriptor_matrix_set_values_offset(p->values_offset, base, pos);
        jdksavdecc_descriptor_matrix_set_number_of_values(p->number_of_values, base, pos);
        jdksavdecc_descriptor_matrix_set_number_of_sources(p->number_of_sources, base, pos);
        jdksavdecc_descriptor_matrix_set_base_source(p->base_source, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_matrix_signal Matrix Signal Descriptor - Clause
 * 7.2.26  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_MATRIX_SIGNAL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_signal_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_MATRIX_SIGNAL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_signal_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_MATRIX_SIGNAL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_signal_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_MATRIX_SIGNAL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_signal_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the uint16 value of the signals_count field of the
 *DESCRIPTOR_MATRIX_SIGNAL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signals_count value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_signal_get_signals_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS_COUNT);
}

/**
 * Store a uint16 value to the signals_count field of the
 *DESCRIPTOR_MATRIX_SIGNAL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signals_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_signal_set_signals_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS_COUNT);
}

/**
 * Extract the uint16 value of the signals_offset field of the
 *DESCRIPTOR_MATRIX_SIGNAL object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signals_offset value
 */
static inline uint16_t jdksavdecc_descriptor_matrix_signal_get_signals_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS_OFFSET);
}

/**
 * Store a uint16 value to the signals_offset field of the
 *DESCRIPTOR_MATRIX_SIGNAL object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signals_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_matrix_signal_set_signals_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_OFFSET_SIGNALS_OFFSET);
}

/*@}*/

/** \addtogroup descriptor_matrix_signal Matrix Signal Descriptor - Clause
 * 7.2.26  */
/*@{*/

/// Matrix Signal Descriptor - Clause 7.2.26
struct jdksavdecc_descriptor_matrix_signal {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    uint16_t signals_count;
    uint16_t signals_offset;
};

/**
 * Extract the jdksavdecc_descriptor_matrix_signal_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.26
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_matrix_signal structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_matrix_signal_read(struct jdksavdecc_descriptor_matrix_signal *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_matrix_signal_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_matrix_signal_get_descriptor_index(base, pos);
        p->signals_count = jdksavdecc_descriptor_matrix_signal_get_signals_count(base, pos);
        p->signals_offset = jdksavdecc_descriptor_matrix_signal_get_signals_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_matrix_signal_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.26
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_matrix_signal structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_matrix_signal_write(struct jdksavdecc_descriptor_matrix_signal const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_MATRIX_SIGNAL_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_matrix_signal_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_matrix_signal_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_matrix_signal_set_signals_count(p->signals_count, base, pos);
        jdksavdecc_descriptor_matrix_signal_set_signals_offset(p->signals_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_signal_splitter SIGNAL_SPLITTER Descriptor - Clause
 * 7.2.27  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_signal_splitter_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_splitter_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_splitter_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint16 value of the number_of_outputs field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_outputs value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_number_of_outputs(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_NUMBER_OF_OUTPUTS);
}

/**
 * Store a uint16 value to the number_of_outputs field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_outputs value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_number_of_outputs(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_NUMBER_OF_OUTPUTS);
}

/**
 * Extract the uint16 value of the splitter_map_count field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t splitter_map_count value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_splitter_map_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP_COUNT);
}

/**
 * Store a uint16 value to the splitter_map_count field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t splitter_map_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_splitter_map_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP_COUNT);
}

/**
 * Extract the uint16 value of the splitter_map_offset field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t splitter_map_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_splitter_get_splitter_map_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP_OFFSET);
}

/**
 * Store a uint16 value to the splitter_map_offset field of the
 *DESCRIPTOR_SIGNAL_SPLITTER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t splitter_map_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_splitter_set_splitter_map_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_OFFSET_SPLITTER_MAP_OFFSET);
}

/*@}*/

/** \addtogroup descriptor_signal_splitter SIGNAL_SPLITTER Descriptor - Clause
 * 7.2.27  */
/*@{*/

/// SIGNAL_SPLITTER Descriptor - Clause 7.2.27
struct jdksavdecc_descriptor_signal_splitter {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint16_t number_of_outputs;
    uint16_t splitter_map_count;
    uint16_t splitter_map_offset;
};

/**
 * Extract the jdksavdecc_descriptor_signal_splitter_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.27
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_signal_splitter structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_splitter_read(struct jdksavdecc_descriptor_signal_splitter *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_signal_splitter_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_signal_splitter_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_signal_splitter_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_signal_splitter_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_signal_splitter_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_signal_splitter_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_signal_splitter_get_control_domain(base, pos);
        p->signal_type = jdksavdecc_descriptor_signal_splitter_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_signal_splitter_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_signal_splitter_get_signal_output(base, pos);
        p->number_of_outputs = jdksavdecc_descriptor_signal_splitter_get_number_of_outputs(base, pos);
        p->splitter_map_count = jdksavdecc_descriptor_signal_splitter_get_splitter_map_count(base, pos);
        p->splitter_map_offset = jdksavdecc_descriptor_signal_splitter_get_splitter_map_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_signal_splitter_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.27
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_signal_splitter structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_splitter_write(struct jdksavdecc_descriptor_signal_splitter const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_SPLITTER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_signal_splitter_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_number_of_outputs(p->number_of_outputs, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_splitter_map_count(p->splitter_map_count, base, pos);
        jdksavdecc_descriptor_signal_splitter_set_splitter_map_offset(p->splitter_map_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_signal_combiner SIGNAL_COMBINER Descriptor - Clause
 * 7.2.28  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_signal_combiner_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_combiner_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_combiner_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the combiner_map_count field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t combiner_map_count value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_combiner_map_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP_COUNT);
}

/**
 * Store a uint16 value to the combiner_map_count field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t combiner_map_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_combiner_map_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP_COUNT);
}

/**
 * Extract the uint16 value of the combiner_map_offset field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t combiner_map_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_combiner_map_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP_OFFSET);
}

/**
 * Store a uint16 value to the combiner_map_offset field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t combiner_map_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_combiner_map_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_COMBINER_MAP_OFFSET);
}

/**
 * Extract the uint16 value of the sources_offset field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sources_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_sources_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_SOURCES_OFFSET);
}

/**
 * Store a uint16 value to the sources_offset field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sources_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_sources_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_SOURCES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_sources field of the
 *DESCRIPTOR_SIGNAL_COMBINER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_sources value
 */
static inline uint16_t jdksavdecc_descriptor_signal_combiner_get_number_of_sources(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Store a uint16 value to the number_of_sources field of the
 *DESCRIPTOR_SIGNAL_COMBINER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_sources value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_combiner_set_number_of_sources(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_OFFSET_NUMBER_OF_SOURCES);
}

/*@}*/

/** \addtogroup descriptor_signal_combiner SIGNAL_COMBINER Descriptor - Clause
 * 7.2.28  */
/*@{*/

/// SIGNAL_COMBINER Descriptor - Clause 7.2.28
struct jdksavdecc_descriptor_signal_combiner {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t combiner_map_count;
    uint16_t combiner_map_offset;
    uint16_t sources_offset;
    uint16_t number_of_sources;
};

/**
 * Extract the jdksavdecc_descriptor_signal_combiner_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.28
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_signal_combiner structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_combiner_read(struct jdksavdecc_descriptor_signal_combiner *p,
                                                                 void const *base,
                                                                 ssize_t pos,
                                                                 size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_signal_combiner_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_signal_combiner_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_signal_combiner_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_signal_combiner_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_signal_combiner_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_signal_combiner_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_signal_combiner_get_control_domain(base, pos);
        p->combiner_map_count = jdksavdecc_descriptor_signal_combiner_get_combiner_map_count(base, pos);
        p->combiner_map_offset = jdksavdecc_descriptor_signal_combiner_get_combiner_map_offset(base, pos);
        p->sources_offset = jdksavdecc_descriptor_signal_combiner_get_sources_offset(base, pos);
        p->number_of_sources = jdksavdecc_descriptor_signal_combiner_get_number_of_sources(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_signal_combiner_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.28
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_signal_combiner structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_combiner_write(struct jdksavdecc_descriptor_signal_combiner const *p,
                                                                  void *base,
                                                                  size_t pos,
                                                                  size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_COMBINER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_signal_combiner_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_combiner_map_count(p->combiner_map_count, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_combiner_map_offset(p->combiner_map_offset, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_sources_offset(p->sources_offset, base, pos);
        jdksavdecc_descriptor_signal_combiner_set_number_of_sources(p->number_of_sources, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_signal_demultiplexer SIGNAL_DEMULTIPLEXER Descriptor
 * - Clause 7.2.29  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_signal_demultiplexer_get_object_name(void const *base,
                                                                                                  ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_signal_demultiplexer_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_demultiplexer_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_demultiplexer_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Extract the uint16 value of the number_of_outputs field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_outputs value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_number_of_outputs(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_NUMBER_OF_OUTPUTS);
}

/**
 * Store a uint16 value to the number_of_outputs field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_outputs value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_number_of_outputs(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_NUMBER_OF_OUTPUTS);
}

/**
 * Extract the uint16 value of the demultiplexer_map_count field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t demultiplexer_map_count value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_demultiplexer_map_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP_COUNT);
}

/**
 * Store a uint16 value to the demultiplexer_map_count field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t demultiplexer_map_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_demultiplexer_set_demultiplexer_map_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP_COUNT);
}

/**
 * Extract the uint16 value of the demultiplexer_map_offset field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object from a network
 *buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t demultiplexer_map_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_demultiplexer_get_demultiplexer_map_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP_OFFSET);
}

/**
 * Store a uint16 value to the demultiplexer_map_offset field of the
 *DESCRIPTOR_SIGNAL_DEMULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t demultiplexer_map_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_signal_demultiplexer_set_demultiplexer_map_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_OFFSET_DEMULTIPLEXER_MAP_OFFSET);
}

/*@}*/

/** \addtogroup descriptor_signal_demultiplexer SIGNAL_DEMULTIPLEXER Descriptor
 * - Clause 7.2.29  */
/*@{*/

/// SIGNAL_DEMULTIPLEXER Descriptor - Clause 7.2.29
struct jdksavdecc_descriptor_signal_demultiplexer {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
    uint16_t number_of_outputs;
    uint16_t demultiplexer_map_count;
    uint16_t demultiplexer_map_offset;
};

/**
 * Extract the jdksavdecc_descriptor_signal_demultiplexer_t structure from a
 *network buffer.
 *
 *  - Clause 7.2.29
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_signal_demultiplexer structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_demultiplexer_read(struct jdksavdecc_descriptor_signal_demultiplexer *p,
                                                                      void const *base,
                                                                      ssize_t pos,
                                                                      size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_signal_demultiplexer_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_signal_demultiplexer_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_signal_demultiplexer_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_signal_demultiplexer_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_signal_demultiplexer_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_signal_demultiplexer_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_signal_demultiplexer_get_control_domain(base, pos);
        p->signal_type = jdksavdecc_descriptor_signal_demultiplexer_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_signal_demultiplexer_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_signal_demultiplexer_get_signal_output(base, pos);
        p->number_of_outputs = jdksavdecc_descriptor_signal_demultiplexer_get_number_of_outputs(base, pos);
        p->demultiplexer_map_count = jdksavdecc_descriptor_signal_demultiplexer_get_demultiplexer_map_count(base, pos);
        p->demultiplexer_map_offset = jdksavdecc_descriptor_signal_demultiplexer_get_demultiplexer_map_offset(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_signal_demultiplexer_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.29
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_signal_demultiplexer structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_demultiplexer_write(
    struct jdksavdecc_descriptor_signal_demultiplexer const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_DEMULTIPLEXER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_signal_demultiplexer_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_signal_output(p->signal_output, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_number_of_outputs(p->number_of_outputs, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_demultiplexer_map_count(p->demultiplexer_map_count, base, pos);
        jdksavdecc_descriptor_signal_demultiplexer_set_demultiplexer_map_offset(p->demultiplexer_map_offset, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_signal_multiplexer SIGNAL_MULTIPLEXER Descriptor -
 * Clause 7.2.30  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_signal_multiplexer_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void
jdksavdecc_descriptor_signal_multiplexer_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_multiplexer_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_signal_multiplexer_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the multiplexer_map_count field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t multiplexer_map_count value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_multiplexer_map_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP_COUNT);
}

/**
 * Store a uint16 value to the multiplexer_map_count field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t multiplexer_map_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_multiplexer_map_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP_COUNT);
}

/**
 * Extract the uint16 value of the multiplexer_map_offset field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t multiplexer_map_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_multiplexer_map_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP_OFFSET);
}

/**
 * Store a uint16 value to the multiplexer_map_offset field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t multiplexer_map_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_multiplexer_map_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_MULTIPLEXER_MAP_OFFSET);
}

/**
 * Extract the uint16 value of the sources_offset field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t sources_offset value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_sources_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_SOURCES_OFFSET);
}

/**
 * Store a uint16 value to the sources_offset field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t sources_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_sources_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_SOURCES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_sources field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_sources value
 */
static inline uint16_t jdksavdecc_descriptor_signal_multiplexer_get_number_of_sources(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_NUMBER_OF_SOURCES);
}

/**
 * Store a uint16 value to the number_of_sources field of the
 *DESCRIPTOR_SIGNAL_MULTIPLEXER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_sources value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_signal_multiplexer_set_number_of_sources(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_OFFSET_NUMBER_OF_SOURCES);
}

/*@}*/

/** \addtogroup descriptor_signal_multiplexer SIGNAL_MULTIPLEXER Descriptor -
 * Clause 7.2.30  */
/*@{*/

/// SIGNAL_MULTIPLEXER Descriptor - Clause 7.2.30
struct jdksavdecc_descriptor_signal_multiplexer {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t multiplexer_map_count;
    uint16_t multiplexer_map_offset;
    uint16_t sources_offset;
    uint16_t number_of_sources;
};

/**
 * Extract the jdksavdecc_descriptor_signal_multiplexer_t structure from a
 *network buffer.
 *
 *  - Clause 7.2.30
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_signal_multiplexer structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_multiplexer_read(struct jdksavdecc_descriptor_signal_multiplexer *p,
                                                                    void const *base,
                                                                    ssize_t pos,
                                                                    size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_signal_multiplexer_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_signal_multiplexer_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_signal_multiplexer_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_signal_multiplexer_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_signal_multiplexer_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_signal_multiplexer_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_signal_multiplexer_get_control_domain(base, pos);
        p->multiplexer_map_count = jdksavdecc_descriptor_signal_multiplexer_get_multiplexer_map_count(base, pos);
        p->multiplexer_map_offset = jdksavdecc_descriptor_signal_multiplexer_get_multiplexer_map_offset(base, pos);
        p->sources_offset = jdksavdecc_descriptor_signal_multiplexer_get_sources_offset(base, pos);
        p->number_of_sources = jdksavdecc_descriptor_signal_multiplexer_get_number_of_sources(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_signal_multiplexer_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.30
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_signal_multiplexer structure to read
 *from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_signal_multiplexer_write(struct jdksavdecc_descriptor_signal_multiplexer const *p,
                                                                     void *base,
                                                                     size_t pos,
                                                                     size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_SIGNAL_MULTIPLEXER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_signal_multiplexer_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_multiplexer_map_count(p->multiplexer_map_count, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_multiplexer_map_offset(p->multiplexer_map_offset, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_sources_offset(p->sources_offset, base, pos);
        jdksavdecc_descriptor_signal_multiplexer_set_number_of_sources(p->number_of_sources, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_transcoder SIGNAL_TRANSCODER Descriptor - Clause
 * 7.2.31  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_TRANSCODER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_TRANSCODER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_transcoder_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_TRANSCODER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint32 value of the block_latency field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t block_latency value
 */
static inline uint32_t jdksavdecc_descriptor_transcoder_get_block_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_BLOCK_LATENCY);
}

/**
 * Store a uint32 value to the block_latency field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t block_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_block_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_BLOCK_LATENCY);
}

/**
 * Extract the uint32 value of the control_latency field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint32_t control_latency value
 */
static inline uint32_t jdksavdecc_descriptor_transcoder_get_control_latency(void const *base, ssize_t pos) {
    return jdksavdecc_uint32_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_LATENCY);
}

/**
 * Store a uint32 value to the control_latency field of the
 *DESCRIPTOR_TRANSCODER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint32_t control_latency value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_control_latency(uint32_t v, void *base, ssize_t pos) {
    jdksavdecc_uint32_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_LATENCY);
}

/**
 * Extract the uint16 value of the control_domain field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_domain value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_control_domain(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Store a uint16 value to the control_domain field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_domain value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_control_domain(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_DOMAIN);
}

/**
 * Extract the uint16 value of the control_value_type field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t control_value_type value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_control_value_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Store a uint16 value to the control_value_type field of the
 *DESCRIPTOR_TRANSCODER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t control_value_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_control_value_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_CONTROL_VALUE_TYPE);
}

/**
 * Extract the uint16 value of the values_offset field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t values_offset value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_values_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_VALUES_OFFSET);
}

/**
 * Store a uint16 value to the values_offset field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t values_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_values_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_VALUES_OFFSET);
}

/**
 * Extract the uint16 value of the number_of_values field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_values value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_number_of_values(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_NUMBER_OF_VALUES);
}

/**
 * Store a uint16 value to the number_of_values field of the
 *DESCRIPTOR_TRANSCODER object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_values value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_number_of_values(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_NUMBER_OF_VALUES);
}

/**
 * Extract the uint16 value of the signal_type field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_type value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_signal_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_TYPE);
}

/**
 * Store a uint16 value to the signal_type field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_signal_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_TYPE);
}

/**
 * Extract the uint16 value of the signal_index field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_index value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_signal_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_INDEX);
}

/**
 * Store a uint16 value to the signal_index field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_signal_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_INDEX);
}

/**
 * Extract the uint16 value of the signal_output field of the
 *DESCRIPTOR_TRANSCODER object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t signal_output value
 */
static inline uint16_t jdksavdecc_descriptor_transcoder_get_signal_output(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_OUTPUT);
}

/**
 * Store a uint16 value to the signal_output field of the DESCRIPTOR_TRANSCODER
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t signal_output value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_transcoder_set_signal_output(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_TRANSCODER_OFFSET_SIGNAL_OUTPUT);
}

/*@}*/

/** \addtogroup descriptor_transcoder SIGNAL_TRANSCODER Descriptor - Clause
 * 7.2.31  */
/*@{*/

/// SIGNAL_TRANSCODER Descriptor - Clause 7.2.31
struct jdksavdecc_descriptor_transcoder {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint32_t block_latency;
    uint32_t control_latency;
    uint16_t control_domain;
    uint16_t control_value_type;
    uint16_t values_offset;
    uint16_t number_of_values;
    uint16_t signal_type;
    uint16_t signal_index;
    uint16_t signal_output;
};

/**
 * Extract the jdksavdecc_descriptor_transcoder_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.31
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_transcoder structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_transcoder_read(struct jdksavdecc_descriptor_transcoder *p, void const *base, ssize_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_TRANSCODER_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_transcoder_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_transcoder_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_transcoder_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_transcoder_get_localized_description(base, pos);
        p->block_latency = jdksavdecc_descriptor_transcoder_get_block_latency(base, pos);
        p->control_latency = jdksavdecc_descriptor_transcoder_get_control_latency(base, pos);
        p->control_domain = jdksavdecc_descriptor_transcoder_get_control_domain(base, pos);
        p->control_value_type = jdksavdecc_descriptor_transcoder_get_control_value_type(base, pos);
        p->values_offset = jdksavdecc_descriptor_transcoder_get_values_offset(base, pos);
        p->number_of_values = jdksavdecc_descriptor_transcoder_get_number_of_values(base, pos);
        p->signal_type = jdksavdecc_descriptor_transcoder_get_signal_type(base, pos);
        p->signal_index = jdksavdecc_descriptor_transcoder_get_signal_index(base, pos);
        p->signal_output = jdksavdecc_descriptor_transcoder_get_signal_output(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_transcoder_t structure to a network buffer.
 *
 *  - Clause 7.2.31
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_transcoder structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t
jdksavdecc_descriptor_transcoder_write(struct jdksavdecc_descriptor_transcoder const *p, void *base, size_t pos, size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_TRANSCODER_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_transcoder_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_transcoder_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_transcoder_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_transcoder_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_transcoder_set_block_latency(p->block_latency, base, pos);
        jdksavdecc_descriptor_transcoder_set_control_latency(p->control_latency, base, pos);
        jdksavdecc_descriptor_transcoder_set_control_domain(p->control_domain, base, pos);
        jdksavdecc_descriptor_transcoder_set_control_value_type(p->control_value_type, base, pos);
        jdksavdecc_descriptor_transcoder_set_values_offset(p->values_offset, base, pos);
        jdksavdecc_descriptor_transcoder_set_number_of_values(p->number_of_values, base, pos);
        jdksavdecc_descriptor_transcoder_set_signal_type(p->signal_type, base, pos);
        jdksavdecc_descriptor_transcoder_set_signal_index(p->signal_index, base, pos);
        jdksavdecc_descriptor_transcoder_set_signal_output(p->signal_output, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_clock_domain CLOCK_DOMAIN Descriptor - Clause 7.2.32
 */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_clock_domain_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_CLOCK_DOMAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_clock_domain_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_CLOCK_DOMAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_clock_domain_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_CLOCK_DOMAIN
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_clock_domain_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_CLOCK_DOMAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the clock_source_index field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_source_index value
 */
static inline uint16_t jdksavdecc_descriptor_clock_domain_get_clock_source_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCE_INDEX);
}

/**
 * Store a uint16 value to the clock_source_index field of the
 *DESCRIPTOR_CLOCK_DOMAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_source_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_clock_source_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCE_INDEX);
}

/**
 * Extract the uint16 value of the clock_sources_offset field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_sources_offset value
 */
static inline uint16_t jdksavdecc_descriptor_clock_domain_get_clock_sources_offset(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES_OFFSET);
}

/**
 * Store a uint16 value to the clock_sources_offset field of the
 *DESCRIPTOR_CLOCK_DOMAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_sources_offset value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_clock_sources_offset(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES_OFFSET);
}

/**
 * Extract the uint16 value of the clock_sources_count field of the
 *DESCRIPTOR_CLOCK_DOMAIN object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t clock_sources_count value
 */
static inline uint16_t jdksavdecc_descriptor_clock_domain_get_clock_sources_count(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES_COUNT);
}

/**
 * Store a uint16 value to the clock_sources_count field of the
 *DESCRIPTOR_CLOCK_DOMAIN object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t clock_sources_count value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_clock_domain_set_clock_sources_count(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_OFFSET_CLOCK_SOURCES_COUNT);
}

/*@}*/

/** \addtogroup descriptor_clock_domain CLOCK_DOMAIN Descriptor - Clause 7.2.32
 */
/*@{*/

/// CLOCK_DOMAIN Descriptor - Clause 7.2.32
struct jdksavdecc_descriptor_clock_domain {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t clock_source_index;
    uint16_t clock_sources_offset;
    uint16_t clock_sources_count;
};

/**
 * Extract the jdksavdecc_descriptor_clock_domain_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.32
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_clock_domain structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_clock_domain_read(struct jdksavdecc_descriptor_clock_domain *p,
                                                              void const *base,
                                                              ssize_t pos,
                                                              size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_clock_domain_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_clock_domain_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_clock_domain_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_clock_domain_get_localized_description(base, pos);
        p->clock_source_index = jdksavdecc_descriptor_clock_domain_get_clock_source_index(base, pos);
        p->clock_sources_offset = jdksavdecc_descriptor_clock_domain_get_clock_sources_offset(base, pos);
        p->clock_sources_count = jdksavdecc_descriptor_clock_domain_get_clock_sources_count(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_clock_domain_t structure to a network buffer.
 *
 *  - Clause 7.2.32
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_clock_domain structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_clock_domain_write(struct jdksavdecc_descriptor_clock_domain const *p,
                                                               void *base,
                                                               size_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CLOCK_DOMAIN_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_clock_domain_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_clock_domain_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_clock_domain_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_clock_domain_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_clock_domain_set_clock_source_index(p->clock_source_index, base, pos);
        jdksavdecc_descriptor_clock_domain_set_clock_sources_offset(p->clock_sources_offset, base, pos);
        jdksavdecc_descriptor_clock_domain_set_clock_sources_count(p->clock_sources_count, base, pos);
    }
    return r;
}

/*@}*/

/** \addtogroup descriptor_control_block CONTROL_BLOCK Descriptor - Clause
 * 7.2.33  */
/*@{*/

/**
 * Extract the uint16 value of the descriptor_type field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_type value
 */
static inline uint16_t jdksavdecc_descriptor_control_block_get_descriptor_type(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Store a uint16 value to the descriptor_type field of the
 *DESCRIPTOR_CONTROL_BLOCK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_type value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_descriptor_type(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_DESCRIPTOR_TYPE);
}

/**
 * Extract the uint16 value of the descriptor_index field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t descriptor_index value
 */
static inline uint16_t jdksavdecc_descriptor_control_block_get_descriptor_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Store a uint16 value to the descriptor_index field of the
 *DESCRIPTOR_CONTROL_BLOCK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t descriptor_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_descriptor_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_DESCRIPTOR_INDEX);
}

/**
 * Extract the string value of the object_name field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the struct jdksavdecc_string_t object_name value
 */
static inline struct jdksavdecc_string jdksavdecc_descriptor_control_block_get_object_name(void const *base, ssize_t pos) {
    return jdksavdecc_string_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_OBJECT_NAME);
}

/**
 * Store a string value to the object_name field of the DESCRIPTOR_CONTROL_BLOCK
 *object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The struct jdksavdecc_string_t object_name value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_object_name(struct jdksavdecc_string v, void *base, ssize_t pos) {
    jdksavdecc_string_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_OBJECT_NAME);
}

/**
 * Extract the uint16 value of the localized_description field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t localized_description value
 */
static inline uint16_t jdksavdecc_descriptor_control_block_get_localized_description(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Store a uint16 value to the localized_description field of the
 *DESCRIPTOR_CONTROL_BLOCK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t localized_description value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_localized_description(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_LOCALIZED_DESCRIPTION);
}

/**
 * Extract the uint16 value of the number_of_controls field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t number_of_controls value
 */
static inline uint16_t jdksavdecc_descriptor_control_block_get_number_of_controls(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Store a uint16 value to the number_of_controls field of the
 *DESCRIPTOR_CONTROL_BLOCK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t number_of_controls value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_number_of_controls(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_NUMBER_OF_CONTROLS);
}

/**
 * Extract the uint16 value of the base_control field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t base_control value
 */
static inline uint16_t jdksavdecc_descriptor_control_block_get_base_control(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_BASE_CONTROL);
}

/**
 * Store a uint16 value to the base_control field of the
 *DESCRIPTOR_CONTROL_BLOCK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t base_control value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_base_control(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_BASE_CONTROL);
}

/**
 * Extract the uint16 value of the final_control_index field of the
 *DESCRIPTOR_CONTROL_BLOCK object from a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @return the uint16_t final_control_index value
 */
static inline uint16_t jdksavdecc_descriptor_control_block_get_final_control_index(void const *base, ssize_t pos) {
    return jdksavdecc_uint16_get(base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_FINAL_CONTROL_INDEX);
}

/**
 * Store a uint16 value to the final_control_index field of the
 *DESCRIPTOR_CONTROL_BLOCK object to a network buffer.
 *
 *
 * No bounds checking of the memory buffer is done. It is the caller's
 *responsibility to pre-validate base and pos.
 *
 * @param v The uint16_t final_control_index value.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 */
static inline void jdksavdecc_descriptor_control_block_set_final_control_index(uint16_t v, void *base, ssize_t pos) {
    jdksavdecc_uint16_set(v, base, pos + JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_OFFSET_FINAL_CONTROL_INDEX);
}

/*@}*/

/** \addtogroup descriptor_control_block CONTROL_BLOCK Descriptor - Clause
 * 7.2.33  */
/*@{*/

/// CONTROL_BLOCK Descriptor - Clause 7.2.33
struct jdksavdecc_descriptor_control_block {
    uint16_t descriptor_type;
    uint16_t descriptor_index;
    struct jdksavdecc_string object_name;
    uint16_t localized_description;
    uint16_t number_of_controls;
    uint16_t base_control;
    uint16_t final_control_index;
};

/**
 * Extract the jdksavdecc_descriptor_control_block_t structure from a network
 *buffer.
 *
 *  - Clause 7.2.33
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p pointer to descriptor_control_block structure to fill in.
 * @param base pointer to raw memory buffer to read from.
 * @param pos offset from base to read the field from;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_control_block_read(struct jdksavdecc_descriptor_control_block *p,
                                                               void const *base,
                                                               ssize_t pos,
                                                               size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_LEN);
    if (r >= 0) {
        p->descriptor_type = jdksavdecc_descriptor_control_block_get_descriptor_type(base, pos);
        p->descriptor_index = jdksavdecc_descriptor_control_block_get_descriptor_index(base, pos);
        p->object_name = jdksavdecc_descriptor_control_block_get_object_name(base, pos);
        p->localized_description = jdksavdecc_descriptor_control_block_get_localized_description(base, pos);
        p->number_of_controls = jdksavdecc_descriptor_control_block_get_number_of_controls(base, pos);
        p->base_control = jdksavdecc_descriptor_control_block_get_base_control(base, pos);
        p->final_control_index = jdksavdecc_descriptor_control_block_get_final_control_index(base, pos);
    }
    return r;
}

/**
 * Store the jdksavdecc_descriptor_control_block_t structure to a network
 *buffer.
 *
 *  - Clause 7.2.33
 *
 * Bounds checking of the buffer size is done.
 *
 * @param p const pointer to descriptor_control_block structure to read from.
 * @param base pointer to raw memory buffer to write to.
 * @param pos offset from base to write the field to;
 * @param len length of the raw memory buffer;
 * @return -1 if the buffer length is insufficent, otherwise the offset of the
 *octet following the structure in the buffer.
 */
static inline ssize_t jdksavdecc_descriptor_control_block_write(struct jdksavdecc_descriptor_control_block const *p,
                                                                void *base,
                                                                size_t pos,
                                                                size_t len) {
    ssize_t r = jdksavdecc_validate_range(pos, len, JDKSAVDECC_DESCRIPTOR_CONTROL_BLOCK_LEN);
    if (r >= 0) {
        jdksavdecc_descriptor_control_block_set_descriptor_type(p->descriptor_type, base, pos);
        jdksavdecc_descriptor_control_block_set_descriptor_index(p->descriptor_index, base, pos);
        jdksavdecc_descriptor_control_block_set_object_name(p->object_name, base, pos);
        jdksavdecc_descriptor_control_block_set_localized_description(p->localized_description, base, pos);
        jdksavdecc_descriptor_control_block_set_number_of_controls(p->number_of_controls, base, pos);
        jdksavdecc_descriptor_control_block_set_base_control(p->base_control, base, pos);
        jdksavdecc_descriptor_control_block_set_final_control_index(p->final_control_index, base, pos);
    }
    return r;
}

/** @todo Add Table 7.6.1.2 Key Types, 7.6.1.2.3 ECC_PUBLIC_256, 7.6.1.2.4
 * ECC_PRIVATE_256, 7.6.1.3 Key Chains */
struct jdksavdecc_aem_ecc_public_256;
struct jdksavdecc_aem_ecc_private_256;

/*@}*/

/*@}*/

/*@}*/

#ifdef __cplusplus
}
#endif
